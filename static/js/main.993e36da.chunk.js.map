{"version":3,"sources":["AlgorithmReducer.js","Maze.js","UtilityFuncs.js","Search.js","Cell/CellActions.js","Cell/Cell.js","Grid/Grid.js","PathFindingAlgos/AStarAlgorithm.js","PathFindingAlgos/DijkstrasAlgorithm.js","DataStructures/Queue.js","PathFindingAlgos/BreadthFirstSearch.js","PathFindingAlgos/BestFirstSearch.js","MazeAlgos/RecursiveDivision.js","Header/Header.js","App.js","index.js"],"names":["ALGO_ACTIONS","initialState","isSearching","isCreatingMaze","algoReducer","state","action","type","payload","console","error","mazeVars","mazeAlgo","varDispatch","a","searchVars","gridCl","clearEntireGrid","outlineGrid","then","timer","ms","Promise","resolve","setTimeout","rnd","min","max","Math","floor","random","rndEven","rndOdd","stopSearch","maxSearchTime","minSearchTime","pathAnimationTime","searchAnimationTime","retracePath","start","end","path","currentCell","push","parentCell","reverse","canCrossDiagonals","search","searching","i","length","cell","isOnPath","setCellRerender","rerender","reject","catch","err","log","CELL_TYPES","cellIsStartOrEnd","posX","posY","grid","startCell","endCell","determineCellType","evt","mouseDown","cellTypeOnMouseDown","cellType","altKey","ctrlKey","x","y","closed","opened","changeCellType","compareAStarCells","b","comparison","fCost","hCost","compareDijkstrasCells","gCost","compareBestFirstCells","Cell","heapIndex","getCellColor","Error","this","CellSquareState","props","useState","useEffect","rerenderCell","document","onmousedown","onmouseup","CellSquare","cellClass","setCellClass","className","style","backgroundColor","onMouseMove","onMouseDown","onMouseEnter","onMouseLeave","onClick","assignFinishOrStart","maxY","maxX","initGrid","row","getMooreNeighbours","neighbours","cellIsInGrid","getVonNeumannNeighbours","forEach","clearWalls","resetCellsForSearch","cellA","cellB","dstX","abs","dstY","animTime","outLine","Grid","id","map","AStarSearch","resetForSearch","Heap","require","openHeap","closedSet","Set","foundPath","empty","pop","neighbour","has","newCostToNeighbour","calculateDistance","updateItem","add","dijkstrasSearch","unvisitedHeap","initHeap","unVisitedNeighbours","filter","tempCurrentCell","newDistanceFromStartToNeighbour","Number","MAX_SAFE_INTEGER","heap","Queue","items","head","tail","item","Object","values","indexOf","size","result","key","breadthFirstSearch","unvisitedQueue","initGCosts","enQueue","deQueue","bestFirstSearch","ORIENTATIONS","startRecursiveDivision","divide","chooseOrientation","leftBound","upperBound","rightBound","lowerBound","horizSpace","vertSpace","orientation","findStart","isHorizontalCut","xStartIdx","yStartIdx","choosePassage","xPassageIdx","yPassageIdx","wallDist","dirX","dirY","drawWall","xWallIdx","yWallIdx","Header","useReducer","dispatch","setCanCrossDiagonals","animationInterval","setAnimationInterval","missingCell","setMissingCell","executePathFinding","algorithm","pathFind","Container","fluid","Row","Col","InputGroup","Prepend","Text","FormControl","aria-describedby","value","onChange","target","interval","num","parseFloat","Form","Check","label","checked","xs","Button","variant","createMaze","Alert","onClose","dismissible","Heading","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.993e36da.chunk.js","sourcesContent":["export const ALGO_ACTIONS = {\r\n  IS_SEARCHING: \"IS_SEARCHING\",\r\n  IS_CREATING_MAZE: \"IS_CREATING_MAZE\",\r\n};\r\n// this state represents( but does not manage) the state of the algorithms so the header can change accordingly\r\nexport const initialState = {\r\n  isSearching: false,\r\n  isCreatingMaze: false,\r\n};\r\n\r\nexport default function algoReducer(state, action) {\r\n  switch (action.type) {\r\n    case ALGO_ACTIONS.IS_SEARCHING:\r\n      return {\r\n        ...state,\r\n        isSearching: action.payload,\r\n      };\r\n    case ALGO_ACTIONS.IS_CREATING_MAZE:\r\n      return {\r\n        ...state,\r\n        isCreatingMaze: action.payload,\r\n      };\r\n    default:\r\n      console.error(\"no matching action types\");\r\n  }\r\n}\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { gridCl } from \"./Grid/Grid\";\r\nimport { searchVars } from \"./Search\";\r\n\r\nexport const mazeVars = { isCreatingMaze: false };\r\n\r\nexport async function createMaze(mazeAlgo, varDispatch) {\r\n  // we cannot create a maze if we are searching or already making one\r\n  if (!mazeVars.isCreatingMaze && !searchVars.isSearching) {\r\n    // set a lock so we cannot create multiple mazes at once\r\n    mazeVars.isCreatingMaze = true;\r\n    // make sure to change state so Header component can change\r\n    varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: true });\r\n\r\n    // clear the grid\r\n    gridCl.clearEntireGrid();\r\n    // outline the grid\r\n    await gridCl.outlineGrid(1).then(() => {\r\n      // once outlined create the maze\r\n      mazeAlgo().then(() => {\r\n        // once done creating return states back to initial\r\n        mazeVars.isCreatingMaze = false;\r\n        varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: false });\r\n      });\r\n    });\r\n  }\r\n}\r\n","export const timer = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nexport const getKeyByValue = (object, value) => {\r\n  return Object.keys(object).find((key) => object[key] === value);\r\n};\r\n\r\nexport const rnd = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nexport const rndEven = (min, max) => {\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2;\r\n  return randomNum;\r\n};\r\n\r\nexport const rndOdd = (min, max) => {\r\n  max = max % 2 === 0 ? max : max - 1;\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2 + 1;\r\n  return randomNum;\r\n};\r\n\r\nexport const clamp = (num, min, max) => Math.min(Math.max(num, min), max);\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { mazeVars } from \"./Maze\";\r\nimport { timer } from \"./UtilityFuncs\";\r\n\r\nexport const searchVars = {\r\n  isSearching: false,\r\n  stopSearch: false,\r\n  maxSearchTime: 3000,\r\n  minSearchTime: 1,\r\n  pathAnimationTime: 10,\r\n  searchAnimationTime: 15,\r\n};\r\n\r\nexport function retracePath(start, end) {\r\n  const path = [];\r\n  var currentCell = end;\r\n\r\n  while (currentCell !== start) {\r\n    path.push(currentCell);\r\n    currentCell = currentCell.parentCell;\r\n  }\r\n  path.reverse();\r\n\r\n  return path;\r\n}\r\n\r\nexport async function pathFind(canCrossDiagonals, varDispatch, search) {\r\n  // canCrossDiagonals: whether the algorithm can jump diagonally(changes the neighbours checked and the path created)\r\n  // varDispatch: dispatch function used to change state for the Header component\r\n  // search: the searching algorithm to use\r\n\r\n  // lock the async function so it can only run one at a time\r\n  if (searchVars.isSearching || mazeVars.isCreatingMaze) {\r\n    return;\r\n  }\r\n  searchVars.isSearching = true;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: true });\r\n  //search for the path\r\n  await searching(canCrossDiagonals, search).then(async (path) => {\r\n    if (path == null) {\r\n      // make sure if we've found a path that the algorithm state is restored\r\n      searchVars.isSearching = false;\r\n      searchVars.stopSearch = false;\r\n      varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: false });\r\n      return;\r\n    }\r\n    //draw the path\r\n    for (let i = 0; i < path.length; i++) {\r\n      const cell = path[i];\r\n      cell.isOnPath = true;\r\n      cell.setCellRerender((rerender) => !rerender);\r\n      await timer(searchVars.pathAnimationTime);\r\n    }\r\n  });\r\n  searchVars.isSearching = false;\r\n  searchVars.stopSearch = false;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: false });\r\n}\r\n\r\nfunction searching(canCrossDiagonals, search) {\r\n  // create a promise that will execute the given search algorithm\r\n  return new Promise((resolve, reject) => {\r\n    resolve(\r\n      search(canCrossDiagonals).catch((err) => {\r\n        console.log(err);\r\n        reject(err);\r\n      })\r\n    );\r\n  });\r\n}\r\n","import { gridCl } from \"../Grid/Grid\";\r\nimport { searchVars } from \"../Search\";\r\n\r\nexport const CELL_TYPES = {\r\n  EMPTY: 0,\r\n  START: 1,\r\n  END: 2,\r\n  OBSTACLE: 3,\r\n};\r\n\r\nexport const assignFinishOrStart = (evt, cell) => {\r\n  if (evt.altKey) {\r\n    // if the cell is the end cell\r\n    if (cell.cellType === CELL_TYPES.END) {\r\n      gridCl.endCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      // if the start cell is this cell\r\n      if (cell.cellType === CELL_TYPES.START) {\r\n        // empty the start cell\r\n        gridCl.startCell = null;\r\n      }\r\n      // if there is a end cell\r\n      if (gridCl.endCell != null) {\r\n        // empty the end cell\r\n        changeCellType(gridCl.endCell, CELL_TYPES.EMPTY);\r\n      }\r\n      // change the end cell to be this cell\r\n      changeCellType(cell, CELL_TYPES.END);\r\n      gridCl.endCell = cell;\r\n    }\r\n  } else if (evt.ctrlKey) {\r\n    // if the cell is the start cell then make it empty\r\n    if (cell.cellType === CELL_TYPES.START) {\r\n      gridCl.startCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      // if the cell type is the end\r\n      if (cell.cellType === CELL_TYPES.END) {\r\n        // empty the end cell\r\n        gridCl.endCell = null;\r\n      }\r\n\r\n      // if there is a start cell\r\n      if (gridCl.startCell != null) {\r\n        // empty it\r\n        changeCellType(gridCl.startCell, CELL_TYPES.EMPTY);\r\n      }\r\n      // make this cell the start\r\n      changeCellType(cell, CELL_TYPES.START);\r\n      gridCl.startCell = cell;\r\n    }\r\n  }\r\n};\r\n\r\nexport const cellIsStartOrEnd = (posX, posY) => {\r\n  return (\r\n    gridCl.grid[posY][posX] === gridCl.startCell ||\r\n    gridCl.grid[posY][posX] === gridCl.endCell\r\n  );\r\n};\r\n\r\nexport const determineCellType = (\r\n  evt,\r\n  mouseDown,\r\n  cellTypeOnMouseDown,\r\n  cell\r\n) => {\r\n  // if the mouse button is down\r\n  if (mouseDown) {\r\n    // if the mouse button has been lifted leave func\r\n    if (cellTypeOnMouseDown === -1) return;\r\n    // if the cellType the mouse is down on to start is empty than we will be putting walls vice-versa\r\n    const cellType =\r\n      cellTypeOnMouseDown === CELL_TYPES.EMPTY\r\n        ? CELL_TYPES.OBSTACLE\r\n        : CELL_TYPES.EMPTY;\r\n\r\n    // if the cellType is not equal to the celltype we are drawing and the alt and ctrl key are not down\r\n    if (cell.cellType !== cellType && !evt.altKey && !evt.ctrlKey) {\r\n      // if the cell is start or end then do not change cell type\r\n      if (cellIsStartOrEnd(cell.x, cell.y)) {\r\n        return;\r\n      }\r\n      // if they are closed or opened and we are searching then do not change cell type\r\n      if ((cell.closed || cell.opened) && searchVars.isSearching) {\r\n        return;\r\n      }\r\n      // change cell type to be the cellType we are drawing\r\n      changeCellType(cell, cellType);\r\n    }\r\n  }\r\n};\r\n\r\nconst changeCellType = (cell, cellType) => {\r\n  // change cell type and rerender the cell\r\n  cell.cellType = cellType;\r\n  cell.setCellRerender((rerender) => !rerender);\r\n};\r\n\r\nexport function compareAStarCells(a, b) {\r\n  // the lower the fCost the higher up in the heap the must be\r\n  var comparison = a.fCost() < b.fCost() ? -1 : 1;\r\n\r\n  // if the fCosts are equal\r\n  if (a.fCost() === b.fCost()) {\r\n    // if the hcost is smaller then the other cells hcost then it succeeds otherwise it is equal\r\n    comparison = a.hCost < b.hCost ? -1 : 0;\r\n  }\r\n\r\n  return comparison;\r\n}\r\n\r\nexport function compareDijkstrasCells(a, b) {\r\n  // the lower the gCost the higher up in the heap the cell must be\r\n  var comparison = a.gCost < b.gCost ? -1 : 1;\r\n  if (a.gCost === b.gCost) {\r\n    comparison = 0;\r\n  }\r\n  return comparison;\r\n}\r\n\r\nexport function compareBestFirstCells(a, b) {\r\n  // the lower the hCost the higher up in the heap the cell must be\r\n  var comparison = a.hCost < b.hCost ? -1 : 1;\r\n  if (a.hCost === b.hCost) {\r\n    comparison = 0;\r\n  }\r\n  return comparison;\r\n}\r\n","import React, { useEffect, useState } from \"react\";\r\nimport {\r\n  assignFinishOrStart,\r\n  determineCellType,\r\n  CELL_TYPES,\r\n} from \"./CellActions\";\r\nimport \"./cell.css\";\r\n\r\nexport default class Cell {\r\n  setCellRerender = null;\r\n  isOnPath = false;\r\n  opened = false;\r\n  closed = false;\r\n  cellType = CELL_TYPES.EMPTY;\r\n\r\n  // #region A* path finding\r\n\r\n  // the cost from this cell to the start cell\r\n  gCost = 0;\r\n  // the cost from this cell to the end cell\r\n  hCost = 0;\r\n\r\n  // the total cost\r\n  fCost = () => this.hCost + this.gCost;\r\n  // #endregion\r\n\r\n  // the index in the heap\r\n  heapIndex = -1;\r\n\r\n  // the referenced parent cell for backtracking and finding the path\r\n  parentCell = null;\r\n\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  getCellColor = () => {\r\n    if (\r\n      (!this.opened && !this.isOnPath && !this.closed) ||\r\n      this.cellType !== 0\r\n    ) {\r\n      switch (this.cellType) {\r\n        case CELL_TYPES.EMPTY:\r\n          return \"rgba(221, 221, 221, 0.603)\";\r\n        case CELL_TYPES.START:\r\n          return \"green\";\r\n        case CELL_TYPES.END:\r\n          return \"red\";\r\n        case CELL_TYPES.OBSTACLE:\r\n          return \"black\";\r\n        default:\r\n          throw new Error(\"Out of range exception\");\r\n      }\r\n    } else if (this.isOnPath) {\r\n      return \"lightskyblue\";\r\n    } else if (this.closed) {\r\n      return \"lightgray\";\r\n    } else if (this.opened) {\r\n      return \"lightgreen\";\r\n    }\r\n  };\r\n}\r\n\r\nvar mouseDown = false;\r\nvar cellTypeOnMouseDown = -1;\r\n\r\nexport function CellSquareState(props) {\r\n  const { cell } = props;\r\n  const [, setCellRerender] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (cell.rerenderCell == null) {\r\n      cell.setCellRerender = setCellRerender;\r\n    }\r\n  }, [cell]);\r\n\r\n  document.onmousedown = () => (mouseDown = true);\r\n\r\n  document.onmouseup = () => {\r\n    mouseDown = false;\r\n    cellTypeOnMouseDown = -1;\r\n  };\r\n\r\n  return <CellSquare state={{ cell }} />;\r\n}\r\n\r\nfunction CellSquare({ state }) {\r\n  const { cell } = state;\r\n  const [cellClass, setCellClass] = useState(\"load-cell\");\r\n  return (\r\n    <div\r\n      className={cellClass}\r\n      style={{ backgroundColor: cell.getCellColor() }}\r\n      onMouseMove={(evt) =>\r\n        determineCellType(evt, mouseDown, cellTypeOnMouseDown, cell)\r\n      }\r\n      onMouseDown={(evt) => {\r\n        cellTypeOnMouseDown = cell.cellType;\r\n        determineCellType(evt, true, cellTypeOnMouseDown, cell);\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (cellClass !== \"cell-hovered\") {\r\n          setCellClass(\"cell-hovered\");\r\n        }\r\n      }}\r\n      onMouseLeave={() => {\r\n        if (cellClass !== \"cell-unhovered\") {\r\n          setCellClass(\"cell-unhovered\");\r\n        }\r\n      }}\r\n      onClick={(evt) => assignFinishOrStart(evt, cell)}\r\n    ></div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport Cell, { CellSquareState } from \"../Cell/Cell\";\r\nimport { CELL_TYPES, cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport \"./grid.css\";\r\n\r\nclass GridCl {\r\n  grid = [];\r\n  startCell = null;\r\n  endCell = null;\r\n  // dims must be odd to work with recursive division\r\n  maxY = 27; // 27\r\n  maxX = 61; // 61\r\n\r\n  constructor() {\r\n    this.initGrid();\r\n  }\r\n  initGrid = () => {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      var row = [];\r\n      for (let x = 0; x < this.maxX; x++) {\r\n        row.push(new Cell(x, y));\r\n      }\r\n      this.grid.push(row);\r\n    }\r\n\r\n    let startCell = this.grid[Math.floor(this.maxY / 2)][\r\n      Math.floor(this.maxX / 4)\r\n    ];\r\n    let endCell = this.grid[Math.floor(this.maxY / 2)][\r\n      Math.floor(this.maxX - this.maxX / 4)\r\n    ];\r\n\r\n    startCell.cellType = CELL_TYPES.START;\r\n    endCell.cellType = CELL_TYPES.END;\r\n\r\n    this.startCell = startCell;\r\n    this.endCell = endCell;\r\n  };\r\n\r\n  getMooreNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n    for (var y = -1; y <= 1; y++) {\r\n      for (var x = -1; x <= 1; x++) {\r\n        if (x === 0 && y === 0) {\r\n          continue;\r\n        }\r\n        if (!this.cellIsInGrid(posX + x, posY + y)) {\r\n          continue;\r\n        }\r\n\r\n        neighbours.push(this.grid[posY + y][posX + x]);\r\n      }\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  getVonNeumannNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n\r\n    if (this.cellIsInGrid(posX - 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX - 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX + 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX + 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY - 1)) {\r\n      neighbours.push(this.grid[posY - 1][posX]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY + 1)) {\r\n      neighbours.push(this.grid[posY + 1][posX]);\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  cellIsInGrid = (x, y) => {\r\n    if (x < 0 || y < 0 || x >= this.maxX || y >= this.maxY) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  clearEntireGrid = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (\r\n          cell.cellType !== CELL_TYPES.EMPTY &&\r\n          cell.cellType !== CELL_TYPES.START &&\r\n          cell.cellType !== CELL_TYPES.END\r\n        ) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  resetForSearch() {\r\n    return new Promise((resolve, reject) => {\r\n      resolve(\r\n        this.resetCellsForSearch().catch((err) => {\r\n          console.log(err);\r\n          reject(err);\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  async resetCellsForSearch() {\r\n    gridCl.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  clearWalls = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        if (cell.cellType === CELL_TYPES.OBSTACLE) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  calculateDistance(cellA, cellB, canCrossDiagonals) {\r\n    if (canCrossDiagonals) {\r\n      // distance for diagonal algorithms is calculated using octile distance\r\n      var dstX = Math.abs(cellA.x - cellB.x);\r\n      var dstY = Math.abs(cellA.y - cellB.y);\r\n\r\n      if (dstX > dstY) {\r\n        return 14 * dstY + 10 * (dstX - dstY);\r\n      }\r\n\r\n      return 14 * dstX + 10 * (dstY - dstX);\r\n    } else {\r\n      // distance for non-diagonal algorithms is calculated using manhattan distance\r\n      return Math.abs(cellA.x - cellB.x) + Math.abs(cellA.y - cellB.y);\r\n    }\r\n  }\r\n\r\n  outlineGrid(animTime) {\r\n    return new Promise((resolve, reject) =>\r\n      resolve(\r\n        this.outLine(animTime).catch((err) => {\r\n          console.log(err);\r\n          reject(err);\r\n        })\r\n      )\r\n    );\r\n  }\r\n  async outLine(animTime) {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      if (!cellIsStartOrEnd(0, y)) {\r\n        this.grid[y][0].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][0].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(this.maxX - 1, y)) {\r\n        this.grid[y][this.maxX - 1].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][this.maxX - 1].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n    for (let x = 0; x < this.maxX; x++) {\r\n      if (!cellIsStartOrEnd(x, 0)) {\r\n        this.grid[0][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[0][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(x, this.maxY - 1)) {\r\n        this.grid[this.maxY - 1][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[this.maxY - 1][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n  }\r\n}\r\n\r\nexport const gridCl = new GridCl();\r\n\r\nfunction Grid() {\r\n  return (\r\n    <section id=\"grid\">\r\n      {gridCl.grid.map((row) =>\r\n        row.map((cell) => {\r\n          return <CellSquareState cell={cell} key={cell.x + \" \" + cell.y} />;\r\n        })\r\n      )}\r\n    </section>\r\n  );\r\n}\r\n\r\nexport default Grid;\r\n","// import Heap from \"../DataStructures/Heap\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareAStarCells } from \"../Cell/CellActions\";\r\nimport { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\n\r\nexport default async function AStarSearch(canCrossDiagonals) {\r\n  await gridCl.resetForSearch();\r\n  // create a heap that will contain any cells that we have opened\r\n  var Heap = require(\"heap\");\r\n  const openHeap = new Heap(compareAStarCells);\r\n\r\n  //closed set containing the cells thats neighbours have been checked\r\n  const closedSet = new Set();\r\n\r\n  // assign start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  // the parent of the start cell is itself for retracing\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n  // insert the start cell into the heap\r\n  openHeap.push(startCell);\r\n  var foundPath = false;\r\n\r\n  while (!openHeap.empty()) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    // get the optimal cell from heap\r\n    const currentCell = openHeap.pop();\r\n\r\n    // if the current cell is end cell we've finished\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    // init empty list of neighbours\r\n    var neighbours = [];\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const neighbour = neighbours[i];\r\n      // if the neighbour is an obstacle or the closed set has the neighbour skip this neighbour check\r\n      if (\r\n        neighbour.cellType === CELL_TYPES.OBSTACLE ||\r\n        closedSet.has(neighbour)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // calculate a new gCost for the neighbour using the currentCells gCost\r\n      var newCostToNeighbour =\r\n        currentCell.gCost +\r\n        gridCl.calculateDistance(currentCell, neighbour, canCrossDiagonals);\r\n\r\n      // if the new gCost is less than the previous one or the neighbour is not opened then we must assign new costs\r\n      if (newCostToNeighbour < neighbour.gCost || !neighbour.opened) {\r\n        // assign the costs\r\n        neighbour.gCost = newCostToNeighbour;\r\n        neighbour.hCost = gridCl.calculateDistance(\r\n          neighbour,\r\n          endCell,\r\n          canCrossDiagonals\r\n        );\r\n        // for retracing, the parent cell of the neighbour is the cell that gave it the optimal costs\r\n        neighbour.parentCell = currentCell;\r\n\r\n        // if the neighbour is not opened\r\n        if (!neighbour.opened) {\r\n          // add it to the heap\r\n          openHeap.push(neighbour);\r\n          // set it as opened\r\n          neighbour.opened = true;\r\n\r\n          //rerender with the color of an opened cell\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        } else {\r\n          // if the neighbour was already opened then that means a lesser gCost was given so we must update its pos in the heap\r\n          openHeap.updateItem(neighbour);\r\n        }\r\n      }\r\n    }\r\n\r\n    //rerender with the color of a closed cell\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    closedSet.add(currentCell);\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  // if we've found a path then retrace it\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareDijkstrasCells } from \"../Cell/CellActions\";\r\n\r\nexport default async function dijkstrasSearch(canCrossDiagonals) {\r\n  /*if a cell is closed it means it has been visited, if it is not closed but is instead open\r\n    then the cells dijkstrasShortest has been assigned, but its neighbours have not been checked. \r\n    To be visited it means that cells neighbours must have been checked.*/\r\n\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  var Heap = require(\"heap\");\r\n\r\n  //create a heap of unvisited cells\r\n  const unvisitedHeap = new Heap(compareDijkstrasCells);\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initHeap(unvisitedHeap);\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n  // the start cell has a cost of 0\r\n  startCell.gCost = 0;\r\n  unvisitedHeap.updateItem(startCell);\r\n\r\n  var currentCell = unvisitedHeap.pop();\r\n  var neighbours = [];\r\n  var foundPath = false;\r\n\r\n  // continue looping until there is not unvisited cells\r\n  while (!unvisitedHeap.empty()) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // loop through all unvisited neighbours\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // calculate the new distance to the neighbour using the distance from the curr to the start plus the distance from the curr to the neighbour\r\n        const newDistanceFromStartToNeighbour =\r\n          tempCurrentCell.gCost +\r\n          gridCl.calculateDistance(\r\n            tempCurrentCell,\r\n            neighbour,\r\n            canCrossDiagonals\r\n          );\r\n\r\n        // if the newDistanceFromStartToNeighbour is smaller then the current shortest\r\n        if (newDistanceFromStartToNeighbour < neighbour.gCost) {\r\n          // assign the new shortest distance\r\n          neighbour.gCost = newDistanceFromStartToNeighbour;\r\n\r\n          // assign the parent cell of the neighbour to be the curr\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          // the neighbour has been opened so rerender\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n          // update its position in the heap\r\n          unvisitedHeap.updateItem(neighbour);\r\n        }\r\n      }\r\n    });\r\n\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n\r\n    // pick the cell with the lowest distance from the start\r\n    currentCell = unvisitedHeap.pop();\r\n\r\n    // if after picking new distances for neighbours the lowest distance cell is still max value it means there is no path.\r\n    if (currentCell.gCost === Number.MAX_SAFE_INTEGER) {\r\n      break;\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  }\r\n  console.log(\"no path found\");\r\n}\r\n\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          // initialize all the gCosts to be as large as possible as none have been visited yet\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n          heap.push(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","export default class Queue {\r\n  items = {};\r\n  head = 0;\r\n  tail = 0;\r\n\r\n  enQueue(item) {\r\n    // add an item at the key tail and increment the tail\r\n    this.items[this.tail] = item;\r\n    this.tail++;\r\n  }\r\n\r\n  contains(item) {\r\n    // check if an item is in the Queue\r\n    return Object.values(this.items).indexOf(item) > -1 ? true : false;\r\n  }\r\n\r\n  deQueue() {\r\n    // if the Queue doesn't have any items return nothing\r\n    if (this.size() <= 0) return undefined;\r\n\r\n    // get the item at the start of the queue\r\n    var item = this.items[this.head];\r\n\r\n    // delte the item at head from items object\r\n    delete this.items[this.head];\r\n\r\n    // there are no items at the head key so we must increment it to point to the next head\r\n    this.head++;\r\n\r\n    // if the head is the tail then reset both to 0\r\n    if (this.head === this.tail) {\r\n      this.head = 0;\r\n      this.tail = 0;\r\n    }\r\n\r\n    // return the head item\r\n    return item;\r\n  }\r\n\r\n  size() {\r\n    // return the size of Queue\r\n    return this.tail - this.head;\r\n  }\r\n\r\n  peek() {\r\n    // peek at the first item\r\n    return this.items[this.head];\r\n  }\r\n\r\n  print() {\r\n    var result = [];\r\n    for (let key in this.items) {\r\n      result.push(this.items[key]);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\nimport Queue from \"../DataStructures/Queue\";\r\n\r\nexport default async function breadthFirstSearch(canCrossDiagonals) {\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  //create a heap of unvisited cells\r\n  const unvisitedQueue = new Queue();\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initGCosts();\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n\r\n  var currentCell = null;\r\n\r\n  var neighbours = [];\r\n  // add to the queue the start cell\r\n  startCell.opened = true;\r\n  startCell.gCost = 0;\r\n  unvisitedQueue.enQueue(startCell);\r\n  var foundPath = false;\r\n\r\n  // continue looping until there is not unvisited cells\r\n  while (unvisitedQueue.size() > 0) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    // dequeue to cell to get the current cell\r\n    currentCell = unvisitedQueue.deQueue();\r\n\r\n    // if the current cell is the end then we have the shortest path\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // loop through all unvisited neighbours\r\n    for (let i = 0; i < unVisitedNeighbours.length; i++) {\r\n      var neighbour = unVisitedNeighbours[i];\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // if the neighbour is not closed or opened\r\n        if (!neighbour.closed && !neighbour.opened) {\r\n          // add neighbour to queue\r\n          unvisitedQueue.enQueue(neighbour);\r\n        }\r\n        // calculate the new distance to the neighbour using the distance from the curr to the start plus the distance from the curr to the neighbour\r\n        const newDistanceFromStartToNeighbour =\r\n          tempCurrentCell.gCost +\r\n          gridCl.calculateDistance(\r\n            tempCurrentCell,\r\n            neighbour,\r\n            canCrossDiagonals\r\n          );\r\n\r\n        // if the newDistanceFromStartToNeighbour is smaller then the current shortest\r\n        if (newDistanceFromStartToNeighbour < neighbour.gCost) {\r\n          // assign the new shortest distance\r\n          neighbour.gCost = newDistanceFromStartToNeighbour;\r\n\r\n          // assign the parent cell of the neighbour to be the curr\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          // the neighbour has been opened so rerender\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        }\r\n      }\r\n    }\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n  }\r\n}\r\n\r\nfunction initGCosts() {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          // initialize all the gCosts to be as large as possible as none have been visited yet\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareBestFirstCells } from \"../Cell/CellActions\";\r\n\r\nexport default async function bestFirstSearch(canCrossDiagonals) {\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n  var Heap = require(\"heap\");\r\n  //create a heap of unvisited cells\r\n  const unvisitedHeap = new Heap(compareBestFirstCells);\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initHeap(unvisitedHeap);\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n\r\n  // the start cell has a cost of 0\r\n  startCell.gCost = 0;\r\n  // calculate hCost\r\n  startCell.hCost = gridCl.calculateDistance(\r\n    startCell,\r\n    endCell,\r\n    canCrossDiagonals\r\n  );\r\n  // update the start cells pos in the heap\r\n  unvisitedHeap.updateItem(startCell);\r\n\r\n  var neighbours = [];\r\n  var foundPath = false;\r\n  // continue looping until there is not unvisited cells\r\n  while (!unvisitedHeap.empty()) {\r\n    var currentCell = unvisitedHeap.pop();\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    // if current cell is end cell we've finished\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    // if lowest distance cell (current cell) is still max value it means there is no path.\r\n    if (currentCell.hCost === Number.MAX_SAFE_INTEGER) {\r\n      break;\r\n    }\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    console.log(neighbours);\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter(\r\n      (x) => !x.closed && !x.opened\r\n    );\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // loop through all unvisited neighbours\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // assign the neighbours hCost\r\n        neighbour.hCost = gridCl.calculateDistance(\r\n          neighbour,\r\n          endCell,\r\n          canCrossDiagonals\r\n        );\r\n\r\n        // assign the parent cell of the neighbour to be the current cell\r\n        neighbour.parentCell = tempCurrentCell;\r\n\r\n        // the neighbour has been opened so rerender\r\n        neighbour.opened = true;\r\n        neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n        // update neighbour's position in the heap\r\n        unvisitedHeap.updateItem(neighbour);\r\n      }\r\n    });\r\n\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n\r\n  // if we found a path retrace it\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n  }\r\n}\r\n\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          // initialize all the gCosts to be as large as possible as none have been visited yet\r\n          cell.hCost = Number.MAX_SAFE_INTEGER;\r\n          heap.push(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { rndEven, rndOdd, timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\n\r\nconst ORIENTATIONS = {\r\n  HORIZONTAL: \"HORIZONTAL\",\r\n  VERTICAL: \"VERTICAL\",\r\n};\r\n\r\nexport default function startRecursiveDivision() {\r\n  // begin the division\r\n  return new Promise((resolve, reject) => {\r\n    resolve(\r\n      divide(\r\n        1,\r\n        1,\r\n        gridCl.maxX - 2, // -1 to make it indexed base and -1 again to add an outline of 1\r\n        gridCl.maxY - 2,\r\n        chooseOrientation(1, 1, gridCl.maxX - 2, gridCl.maxY - 2)\r\n      ).catch((err) => {\r\n        console.log(err);\r\n        reject(err);\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\nfunction chooseOrientation(leftBound, upperBound, rightBound, lowerBound) {\r\n  // if the horizontal space is greater than the vertical cut vertically vice-versa\r\n  const horizSpace = rightBound - leftBound;\r\n  const vertSpace = lowerBound - upperBound;\r\n  if (horizSpace > vertSpace) {\r\n    return ORIENTATIONS.VERTICAL;\r\n  } else if (vertSpace > horizSpace) {\r\n    return ORIENTATIONS.HORIZONTAL;\r\n  } else {\r\n    return Math.random() > 0.5\r\n      ? ORIENTATIONS.HORIZONTAL\r\n      : ORIENTATIONS.VERTICAL;\r\n  }\r\n}\r\n\r\nasync function divide(\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound,\r\n  orientation\r\n) {\r\n  if (rightBound - leftBound < 2 || lowerBound - upperBound < 2) {\r\n    return;\r\n  }\r\n\r\n  var isHorizontalCut = orientation === ORIENTATIONS.HORIZONTAL;\r\n\r\n  // find the point to start the wall at\r\n  const { xStartIdx, yStartIdx } = findStart(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n\r\n  // find the point to place the passage\r\n  const { xPassageIdx, yPassageIdx } = choosePassage(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n  // calculate the max distance the wall can span\r\n  var wallDist = isHorizontalCut\r\n    ? rightBound - leftBound\r\n    : lowerBound - upperBound;\r\n  // get the direction to move in according to whether it is a horiz or vert wall\r\n  var dirX = isHorizontalCut ? 1 : 0;\r\n  var dirY = isHorizontalCut ? 0 : 1;\r\n\r\n  await drawWall(\r\n    xStartIdx,\r\n    yStartIdx,\r\n    xPassageIdx,\r\n    yPassageIdx,\r\n    wallDist,\r\n    dirX,\r\n    dirY\r\n  );\r\n\r\n  if (isHorizontalCut) {\r\n    // top section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      rightBound,\r\n      yStartIdx - 1,\r\n      chooseOrientation(leftBound, upperBound, rightBound, yStartIdx - 1)\r\n    );\r\n    // bottom section\r\n    await divide(\r\n      leftBound,\r\n      yStartIdx + 1,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, yStartIdx + 1, rightBound, lowerBound)\r\n    );\r\n  } else {\r\n    // left section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      xStartIdx - 1,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, upperBound, xStartIdx - 1, lowerBound)\r\n    );\r\n\r\n    // right section\r\n    await divide(\r\n      xStartIdx + 1,\r\n      upperBound,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(xStartIdx + 1, upperBound, rightBound, lowerBound)\r\n    );\r\n  }\r\n}\r\n\r\nasync function drawWall(\r\n  xStartIdx,\r\n  yStartIdx,\r\n  xPassageIdx,\r\n  yPassageIdx,\r\n  wallDist,\r\n  dirX,\r\n  dirY\r\n) {\r\n  // set the starting point to draw the wall\r\n  var xWallIdx = xStartIdx;\r\n  var yWallIdx = yStartIdx;\r\n\r\n  // loop through the distance of the wall\r\n  for (let i = 0; i <= wallDist; i++) {\r\n    // to make the space for the passage we just avoid putting a wall where the passage occurs\r\n    // we also musn't put a wall where the start or end cells are\r\n    if (\r\n      xWallIdx === xPassageIdx ||\r\n      yWallIdx === yPassageIdx ||\r\n      cellIsStartOrEnd(xWallIdx, yWallIdx)\r\n    ) {\r\n      xWallIdx += dirX;\r\n      yWallIdx += dirY;\r\n      continue;\r\n    }\r\n    // draw the wall at the indices and rerender\r\n    gridCl.grid[yWallIdx][xWallIdx].cellType = CELL_TYPES.OBSTACLE;\r\n    gridCl.grid[yWallIdx][xWallIdx].setCellRerender((rerender) => !rerender);\r\n\r\n    // increment the indices according to the direction\r\n    xWallIdx += dirX;\r\n    yWallIdx += dirY;\r\n\r\n    // timer is used for animation\r\n    await timer(1);\r\n  }\r\n}\r\n\r\nfunction choosePassage(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  // choose a passage between the given bounds\r\n  var xPassageIdx = 0;\r\n  var yPassageIdx = 0;\r\n\r\n  // must be any odd number between a range because walls are created on even numbers\r\n  if (isHorizontalCut) {\r\n    xPassageIdx = rndOdd(leftBound, rightBound);\r\n    yPassageIdx = upperBound;\r\n  } else {\r\n    xPassageIdx = leftBound;\r\n    yPassageIdx = rndOdd(upperBound, lowerBound);\r\n  }\r\n\r\n  return { xPassageIdx, yPassageIdx };\r\n}\r\n\r\nfunction findStart(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xStartIdx = 0;\r\n  var yStartIdx = 0;\r\n  if (isHorizontalCut) {\r\n    xStartIdx = leftBound;\r\n    /* a horiz wall needs to be on any random EVEN column because the lowerBound - 1 and\r\n    upperBound + 1 are both EVEN inclusive ranges when it is a grid whose Y-axis length is ODD\r\n    and an outline of 1 is applied (you dont wanna place walls right beside a bound as there would be no room for a path)*/\r\n    yStartIdx = rndEven(upperBound + 1, lowerBound - 1);\r\n  } else {\r\n    /* a vert wall needs to be on any random EVEN row because the rightBound - 1 and\r\n    leftBound + 1 are both EVEN inclusive ranges when it is a grid whose X-axis length is \r\n    ODD and an outline of 1 is applied (you dont wanna place walls right beside a bound as there would be no room for a path)*/\r\n    xStartIdx = rndEven(leftBound + 1, rightBound - 1);\r\n    yStartIdx = upperBound;\r\n  }\r\n\r\n  return { xStartIdx, yStartIdx };\r\n}\r\n","import React, { useReducer, useState } from \"react\";\r\nimport {\r\n  Alert,\r\n  Button,\r\n  Col,\r\n  Container,\r\n  Form,\r\n  FormControl,\r\n  InputGroup,\r\n  Row,\r\n} from \"react-bootstrap\";\r\nimport AStarSearch from \"../PathFindingAlgos/AStarAlgorithm\";\r\nimport dijkstrasSearch from \"../PathFindingAlgos/DijkstrasAlgorithm\";\r\nimport breadthFirstSearch from \"../PathFindingAlgos/BreadthFirstSearch\";\r\nimport bestFirstSearch from \"../PathFindingAlgos/BestFirstSearch\";\r\nimport startRecursiveDivision from \"../MazeAlgos/RecursiveDivision\";\r\nimport { searchVars, pathFind } from \"../Search\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { mazeVars, createMaze } from \"../Maze\";\r\nimport algoReducer, { initialState } from \"../AlgorithmReducer\";\r\nimport { clamp } from \"../UtilityFuncs\";\r\nimport \"./header.css\";\r\n\r\nfunction Header() {\r\n  const [state, dispatch] = useReducer(algoReducer, initialState);\r\n\r\n  const [canCrossDiagonals, setCanCrossDiagonals] = useState(true);\r\n  const [animationInterval, setAnimationInterval] = useState(15);\r\n  const [missingCell, setMissingCell] = useState(false);\r\n\r\n  const executePathFinding = (algorithm) => {\r\n    if (gridCl.startCell != null && gridCl.endCell != null) {\r\n      pathFind(canCrossDiagonals, dispatch, algorithm);\r\n    } else {\r\n      setMissingCell(true);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Container id=\"header\" className=\"py-3\" fluid>\r\n      <Row className=\"unselectable\">\r\n        <Col>\r\n          <InputGroup className=\"mt-3\">\r\n            <InputGroup.Prepend>\r\n              <InputGroup.Text id=\"prepending-text\">\r\n                Animation Interval (ms)\r\n              </InputGroup.Text>\r\n            </InputGroup.Prepend>\r\n            <FormControl\r\n              id=\"basic-number\"\r\n              aria-describedby=\"prepending-text\"\r\n              value={animationInterval}\r\n              onChange={(evt) => {\r\n                if (evt.target.value !== \"\") {\r\n                  let interval = clamp(\r\n                    parseFloat(evt.target.value),\r\n                    searchVars.minSearchTime,\r\n                    searchVars.maxSearchTime\r\n                  );\r\n                  setAnimationInterval(interval);\r\n                  searchVars.searchAnimationTime = interval;\r\n                }\r\n              }}\r\n              min={searchVars.minSearchTime}\r\n              max={searchVars.maxSearchTime}\r\n              type=\"number\"\r\n            />\r\n          </InputGroup>\r\n        </Col>\r\n        <Col className=\"can-cross-diagonals\">\r\n          <Form>\r\n            <Form.Check\r\n              type=\"switch\"\r\n              id=\"custom-switch\"\r\n              label=\"Can Cross Diagonals\"\r\n              checked={canCrossDiagonals}\r\n              onChange={() =>\r\n                setCanCrossDiagonals((canCrossDiagonals) => !canCrossDiagonals)\r\n              }\r\n            />\r\n          </Form>\r\n        </Col>\r\n        <Col xs={4} className=\"algorithms\">\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => createMaze(startRecursiveDivision, dispatch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Create Maze\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(AStarSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            A*\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(dijkstrasSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Dijkstras\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(breadthFirstSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Breadth First Search\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(bestFirstSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Best First Search\r\n          </Button>\r\n        </Col>\r\n        <Col className=\"clears\">\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (!searchVars.isSearching && !mazeVars.isCreatingMaze) {\r\n                gridCl.clearEntireGrid();\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Clear Entire Grid\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (!mazeVars.isCreatingMaze) {\r\n                gridCl.clearWalls();\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={state.isCreatingMaze ? \"disabled\" : \"\"}\r\n          >\r\n            Clear Walls\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (searchVars.isSearching) {\r\n                searchVars.stopSearch = true;\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={state.isSearching ? \"\" : \"disabled\"}\r\n          >\r\n            Stop Search\r\n          </Button>\r\n        </Col>\r\n        <Col xs={2}>\r\n          <p>\r\n            <b>Ctrl Click:</b> set start cell\r\n          </p>\r\n          <p>\r\n            <b>Alt Click:</b> set end cell\r\n          </p>\r\n        </Col>\r\n      </Row>\r\n      {missingCell ? (\r\n        <Alert\r\n          variant={\"danger\"}\r\n          onClose={() => setMissingCell(false)}\r\n          dismissible\r\n        >\r\n          <Alert.Heading>You are missing a start or end cell</Alert.Heading>\r\n        </Alert>\r\n      ) : (\r\n        <div></div>\r\n      )}\r\n    </Container>\r\n  );\r\n}\r\n\r\nexport default Header;\r\n","import Grid from \"./Grid/Grid\";\nimport Header from \"./Header/Header\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}