{"version":3,"sources":["AlgorithmReducer.js","Maze.js","UtilityFuncs.js","Search.js","Cell/CellActions.js","Cell/Cell.js","Grid/Grid.js","DataStructures/Heap.js","PathFindingAlgos/AStarAlgorithm.js","PathFindingAlgos/DijkstrasAlgorithm.js","DataStructures/Queue.js","PathFindingAlgos/BreadthFirstSearch.js","PathFindingAlgos/BestFirstSearch.js","MazeAlgos/RecursiveDivision.js","Header/Header.js","App.js","index.js"],"names":["ALGO_ACTIONS","initialState","isSearching","isCreatingMaze","algoReducer","state","action","type","payload","console","error","mazeVars","mazeAlgo","varDispatch","a","searchVars","gridCl","clearEntireGrid","outlineGrid","then","timer","ms","Promise","resolve","setTimeout","rnd","min","max","Math","floor","random","rndEven","rndOdd","SEARCH_TYPES","stopSearch","maxSearchTime","minSearchTime","pathAnimationTime","searchAnimationTime","retracePath","start","end","path","currentCell","push","parentCell","reverse","canCrossDiagonals","search","searching","i","length","cell","isOnPath","setCellRerender","rerender","reject","catch","err","log","CELL_TYPES","cellIsStartOrEnd","posX","posY","grid","startCell","endCell","determineCellType","evt","mouseDown","cellTypeOnMouseDown","cellType","altKey","ctrlKey","x","y","closed","opened","changeCellType","Cell","gCost","Number","MAX_SAFE_INTEGER","hCost","fCost","heapIndex","getCellColor","Error","this","cellToCompare","searchType","comparison","CellSquareState","props","useState","useEffect","rerenderCell","document","onmousedown","onmouseup","CellSquare","cellClass","setCellClass","className","style","backgroundColor","onMouseMove","onMouseDown","onMouseEnter","onMouseLeave","onClick","assignFinishOrStart","maxY","maxX","initGrid","row","getMooreNeighbours","neighbours","cellIsInGrid","getVonNeumannNeighbours","forEach","clearWalls","resetCellsForSearch","cellA","cellB","dstX","abs","dstY","animTime","outLine","Grid","id","map","Heap","items","lastHeapItemIndex","item","includes","sortUp","firstCell","pop","sortDown","parentIndex","compareTo","swap","leftChildIndex","rightChildIndex","swapIndex","itemA","itemB","item_A_index","AStarSearch","resetForSearch","openHeap","closedSet","Set","add","foundPath","removeFirst","neighbour","has","newCostToNeighbour","calculateDistance","contains","update","dijkstrasSearch","unvisitedHeap","initHeap","unVisitedNeighbours","filter","tempCurrentCell","newDistanceFromStartToNeighbour","heap","Queue","head","tail","result","key","breadthFirstSearch","unvisitedQueue","initGCosts","enQueue","undefined","deQueue","size","bestFirstSearch","ORIENTATIONS","startRecursiveDivision","divide","chooseOrientation","leftBound","upperBound","rightBound","lowerBound","horizSpace","vertSpace","orientation","findStart","isHorizontalCut","xStartIdx","yStartIdx","choosePassage","xPassageIdx","yPassageIdx","wallDist","dirX","dirY","drawWall","xWallIdx","yWallIdx","Header","useReducer","dispatch","setCanCrossDiagonals","animationInterval","setAnimationInterval","missingCell","setMissingCell","executePathFinding","algorithm","pathFind","Container","fluid","Row","Col","InputGroup","Prepend","Text","FormControl","aria-describedby","value","onChange","target","interval","num","parseFloat","step","Form","Check","label","checked","xs","Button","variant","createMaze","Alert","onClose","dismissible","Heading","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.26672cd7.chunk.js","sourcesContent":["export const ALGO_ACTIONS = {\r\n  IS_SEARCHING: \"IS_SEARCHING\",\r\n  IS_CREATING_MAZE: \"IS_CREATING_MAZE\",\r\n};\r\n\r\nexport const initialState = {\r\n  isSearching: false,\r\n  isCreatingMaze: false,\r\n};\r\n\r\nexport default function algoReducer(state, action) {\r\n  switch (action.type) {\r\n    case ALGO_ACTIONS.IS_SEARCHING:\r\n      return {\r\n        ...state,\r\n        isSearching: action.payload,\r\n      };\r\n    case ALGO_ACTIONS.IS_CREATING_MAZE:\r\n      return {\r\n        ...state,\r\n        isCreatingMaze: action.payload,\r\n      };\r\n    default:\r\n      console.error(\"no matching action types\");\r\n  }\r\n}\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { gridCl } from \"./Grid/Grid\";\r\nimport { searchVars } from \"./Search\";\r\n\r\nexport const mazeVars = { isCreatingMaze: false };\r\n\r\nexport async function createMaze(mazeAlgo, varDispatch) {\r\n  if (!mazeVars.isCreatingMaze && !searchVars.isSearching) {\r\n    mazeVars.isCreatingMaze = true;\r\n    varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: true });\r\n    gridCl.clearEntireGrid();\r\n    await gridCl.outlineGrid(1).then(() => {\r\n      mazeAlgo().then(() => {\r\n        mazeVars.isCreatingMaze = false;\r\n        varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: false });\r\n      });\r\n    });\r\n  }\r\n}\r\n","export const timer = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nexport const getKeyByValue = (object, value) => {\r\n  return Object.keys(object).find((key) => object[key] === value);\r\n};\r\n\r\nexport const rnd = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nexport const rndEven = (min, max) => {\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2;\r\n  return randomNum;\r\n};\r\n\r\nexport const rndOdd = (min, max) => {\r\n  max = max % 2 === 0 ? max : max - 1;\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2 + 1;\r\n  return randomNum;\r\n};\r\n\r\nexport const clamp = (num, min, max) => Math.min(Math.max(num, min), max);\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { mazeVars } from \"./Maze\";\r\nimport { timer } from \"./UtilityFuncs\";\r\n\r\nexport const SEARCH_TYPES = {\r\n  A_STAR: \"A*\",\r\n  DIJKSTRA: \"DIJKSTRA\",\r\n  BEST_FIRST: \"BEST_FIRST\",\r\n};\r\n\r\nexport const searchVars = {\r\n  isSearching: false,\r\n  stopSearch: false,\r\n  maxSearchTime: 3000,\r\n  minSearchTime: 1,\r\n  pathAnimationTime: 10,\r\n  searchAnimationTime: 15,\r\n};\r\n\r\nexport function retracePath(start, end) {\r\n  const path = [];\r\n  var currentCell = end;\r\n\r\n  while (currentCell !== start) {\r\n    path.push(currentCell);\r\n    currentCell = currentCell.parentCell;\r\n  }\r\n  path.reverse();\r\n\r\n  return path;\r\n}\r\n\r\nexport async function pathFind(canCrossDiagonals, varDispatch, search) {\r\n  // lock the async function so it can only run one at a time\r\n  if (searchVars.isSearching || mazeVars.isCreatingMaze) {\r\n    return;\r\n  }\r\n  searchVars.isSearching = true;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: true });\r\n  //search for the path\r\n  await searching(canCrossDiagonals, search).then(async (path) => {\r\n    if (path == null) {\r\n      searchVars.isSearching = false;\r\n      searchVars.stopSearch = false;\r\n      varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: false });\r\n      return;\r\n    }\r\n    //draw the path\r\n    for (let i = 0; i < path.length; i++) {\r\n      const cell = path[i];\r\n      cell.isOnPath = true;\r\n      cell.setCellRerender((rerender) => !rerender);\r\n      await timer(searchVars.pathAnimationTime);\r\n    }\r\n  });\r\n  searchVars.isSearching = false;\r\n  searchVars.stopSearch = false;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: false });\r\n}\r\n\r\nfunction searching(canCrossDiagonals, search) {\r\n  return new Promise((resolve, reject) => {\r\n    resolve(\r\n      search(canCrossDiagonals).catch((err) => {\r\n        console.log(err);\r\n        reject(err);\r\n      })\r\n    );\r\n  });\r\n}\r\n","import { gridCl } from \"../Grid/Grid\";\r\nimport { searchVars } from \"../Search\";\r\n\r\nexport const CELL_TYPES = {\r\n  EMPTY: 0,\r\n  START: 1,\r\n  END: 2,\r\n  OBSTACLE: 3,\r\n};\r\n\r\nexport const assignFinishOrStart = (evt, cell) => {\r\n  if (evt.altKey) {\r\n    // if the cell is the end cell\r\n    if (cell.cellType === CELL_TYPES.END) {\r\n      gridCl.endCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      // if the start cell is this cell\r\n      if (cell.cellType === CELL_TYPES.START) {\r\n        // empty the start cell\r\n        gridCl.startCell = null;\r\n      }\r\n      // if there is a end cell\r\n      if (gridCl.endCell != null) {\r\n        // empty the end cell\r\n        changeCellType(gridCl.endCell, CELL_TYPES.EMPTY);\r\n      }\r\n      // change the end cell to be this cell\r\n      changeCellType(cell, CELL_TYPES.END);\r\n      gridCl.endCell = cell;\r\n    }\r\n  } else if (evt.ctrlKey) {\r\n    // if the cell is the start cell then make it empty\r\n    if (cell.cellType === CELL_TYPES.START) {\r\n      gridCl.startCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      // if the cell type is the end\r\n      if (cell.cellType === CELL_TYPES.END) {\r\n        // empty the end cell\r\n        gridCl.endCell = null;\r\n      }\r\n\r\n      // if there is a start cell\r\n      if (gridCl.startCell != null) {\r\n        // empty it\r\n        changeCellType(gridCl.startCell, CELL_TYPES.EMPTY);\r\n      }\r\n      // make this cell the start\r\n      changeCellType(cell, CELL_TYPES.START);\r\n      gridCl.startCell = cell;\r\n    }\r\n  }\r\n};\r\n\r\nexport const cellIsStartOrEnd = (posX, posY) => {\r\n  return (\r\n    gridCl.grid[posY][posX] === gridCl.startCell ||\r\n    gridCl.grid[posY][posX] === gridCl.endCell\r\n  );\r\n};\r\n\r\nexport const determineCellType = (\r\n  evt,\r\n  mouseDown,\r\n  cellTypeOnMouseDown,\r\n  cell\r\n) => {\r\n  if (mouseDown) {\r\n    if (cellTypeOnMouseDown === -1) return;\r\n    const cellType =\r\n      cellTypeOnMouseDown === CELL_TYPES.EMPTY\r\n        ? CELL_TYPES.OBSTACLE\r\n        : CELL_TYPES.EMPTY;\r\n    if (cell.cellType !== cellType && !evt.altKey && !evt.ctrlKey) {\r\n      if (cellIsStartOrEnd(cell.x, cell.y)) {\r\n        return;\r\n      }\r\n      if ((cell.closed || cell.opened) && searchVars.isSearching) {\r\n        return;\r\n      }\r\n      changeCellType(cell, cellType);\r\n    }\r\n  }\r\n};\r\n\r\nconst changeCellType = (cell, cellType) => {\r\n  cell.cellType = cellType;\r\n  cell.setCellRerender((rerender) => !rerender);\r\n};\r\n","import React, { useEffect, useState } from \"react\";\r\nimport {\r\n  assignFinishOrStart,\r\n  determineCellType,\r\n  CELL_TYPES,\r\n} from \"./CellActions\";\r\nimport { SEARCH_TYPES } from \"../Search\";\r\nimport \"./cell.css\";\r\n\r\nexport default class Cell {\r\n  setCellRerender = null;\r\n  isOnPath = false;\r\n  opened = false;\r\n  closed = false;\r\n  cellType = CELL_TYPES.EMPTY;\r\n\r\n  // #region A* path finding\r\n\r\n  // the cost from this cell to the start cell\r\n  gCost = Number.MAX_SAFE_INTEGER;\r\n  // the cost from this cell to the end cell\r\n  hCost = 0;\r\n\r\n  // the total cost\r\n  fCost = () => this.hCost + this.gCost;\r\n  // #endregion\r\n\r\n  // the index in the heap\r\n  heapIndex = -1;\r\n\r\n  // the referenced parent cell for backtracking and finding the path\r\n  parentCell = null;\r\n\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  getCellColor = () => {\r\n    if (\r\n      (!this.opened && !this.isOnPath && !this.closed) ||\r\n      this.cellType !== 0\r\n    ) {\r\n      switch (this.cellType) {\r\n        case CELL_TYPES.EMPTY:\r\n          return \"rgba(221, 221, 221, 0.603)\";\r\n        case CELL_TYPES.START:\r\n          return \"green\";\r\n        case CELL_TYPES.END:\r\n          return \"red\";\r\n        case CELL_TYPES.OBSTACLE:\r\n          return \"black\";\r\n        default:\r\n          throw new Error(\"Out of range exception\");\r\n      }\r\n    } else if (this.isOnPath) {\r\n      return \"lightskyblue\";\r\n    } else if (this.closed) {\r\n      return \"lightgray\";\r\n    } else if (this.opened) {\r\n      return \"lightgreen\";\r\n    }\r\n  };\r\n\r\n  compareTo(cellToCompare, searchType) {\r\n    // the cell with the lowest fCost will always be at the top of the heap(indexed at 0) therefore smaller fCosts will precede\r\n\r\n    // -1 = precedes\r\n    // 0 = equal\r\n    // 1 = succeeds\r\n    var comparison = 0;\r\n    switch (searchType) {\r\n      case SEARCH_TYPES.A_STAR:\r\n        // if the fcost is smaller then the other cells fcost then it succeeds otherwise it precedes\r\n        comparison = this.fCost() < cellToCompare.fCost() ? 1 : -1;\r\n\r\n        // if the fCosts are equal\r\n        if (this.fCost() === cellToCompare.fCost()) {\r\n          // if the hcost is smaller then the other cells hcost then it succeeds otherwise it is equal\r\n          comparison = this.hCost < cellToCompare.hCost ? 1 : 0;\r\n        }\r\n\r\n        //return the comparison\r\n        return comparison;\r\n      case SEARCH_TYPES.DIJKSTRA:\r\n        comparison = this.gCost < cellToCompare.gCost ? 1 : -1;\r\n        if (this.gCost === cellToCompare.gCost) {\r\n          comparison = 0;\r\n        }\r\n        return comparison;\r\n      case SEARCH_TYPES.BEST_FIRST:\r\n        comparison = this.hCost < cellToCompare.hCost ? 1 : -1;\r\n        if (this.hCost === cellToCompare.hCost) {\r\n          comparison = 0;\r\n        }\r\n        return comparison;\r\n      default:\r\n        throw new Error(\"No proper search type given\");\r\n    }\r\n  }\r\n}\r\n\r\nvar mouseDown = false;\r\nvar cellTypeOnMouseDown = -1;\r\n\r\nexport function CellSquareState(props) {\r\n  const { cell } = props;\r\n  const [, setCellRerender] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (cell.rerenderCell == null) {\r\n      cell.setCellRerender = setCellRerender;\r\n    }\r\n  }, [cell]);\r\n\r\n  document.onmousedown = () => (mouseDown = true);\r\n\r\n  document.onmouseup = () => {\r\n    mouseDown = false;\r\n    cellTypeOnMouseDown = -1;\r\n  };\r\n\r\n  return <CellSquare state={{ cell }} />;\r\n}\r\n\r\nfunction CellSquare({ state }) {\r\n  const { cell } = state;\r\n  const [cellClass, setCellClass] = useState(\"load-cell\");\r\n\r\n  return (\r\n    <div\r\n      className={cellClass}\r\n      style={{ backgroundColor: cell.getCellColor() }}\r\n      onMouseMove={(evt) =>\r\n        determineCellType(evt, mouseDown, cellTypeOnMouseDown, cell)\r\n      }\r\n      onMouseDown={(evt) => {\r\n        cellTypeOnMouseDown = cell.cellType;\r\n        determineCellType(evt, true, cellTypeOnMouseDown, cell);\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (cellClass !== \"cell-hovered\") {\r\n          setCellClass(\"cell-hovered\");\r\n        }\r\n      }}\r\n      onMouseLeave={() => {\r\n        if (cellClass !== \"cell-unhovered\") {\r\n          setCellClass(\"cell-unhovered\");\r\n        }\r\n      }}\r\n      onClick={(evt) => assignFinishOrStart(evt, cell)}\r\n    >\r\n      <p>{/* X: {cell.x} Y: {cell.y} */}</p>\r\n    </div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport Cell, { CellSquareState } from \"../Cell/Cell\";\r\nimport { CELL_TYPES, cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport \"./grid.css\";\r\n\r\nclass GridCl {\r\n  grid = [];\r\n  startCell = null;\r\n  endCell = null;\r\n  // dims must be odd to work with recursive division\r\n  maxY = 27;\r\n  maxX = 63;\r\n\r\n  constructor() {\r\n    this.initGrid();\r\n  }\r\n  initGrid = () => {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      var row = [];\r\n      for (let x = 0; x < this.maxX; x++) {\r\n        row.push(new Cell(x, y));\r\n      }\r\n      this.grid.push(row);\r\n    }\r\n\r\n    let startCell = this.grid[Math.floor(this.maxY / 2)][\r\n      Math.floor(this.maxX / 4)\r\n    ];\r\n    let endCell = this.grid[Math.floor(this.maxY / 2)][\r\n      Math.floor(this.maxX - this.maxX / 4)\r\n    ];\r\n\r\n    startCell.cellType = CELL_TYPES.START;\r\n    endCell.cellType = CELL_TYPES.END;\r\n\r\n    this.startCell = startCell;\r\n    this.endCell = endCell;\r\n  };\r\n\r\n  getMooreNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n    for (var y = -1; y <= 1; y++) {\r\n      for (var x = -1; x <= 1; x++) {\r\n        if (x === 0 && y === 0) {\r\n          continue;\r\n        }\r\n        if (!this.cellIsInGrid(posX + x, posY + y)) {\r\n          continue;\r\n        }\r\n\r\n        neighbours.push(this.grid[posY + y][posX + x]);\r\n      }\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  getVonNeumannNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n\r\n    if (this.cellIsInGrid(posX - 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX - 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX + 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX + 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY - 1)) {\r\n      neighbours.push(this.grid[posY - 1][posX]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY + 1)) {\r\n      neighbours.push(this.grid[posY + 1][posX]);\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  cellIsInGrid = (x, y) => {\r\n    if (x < 0 || y < 0 || x >= this.maxX || y >= this.maxY) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  clearEntireGrid = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (\r\n          cell.cellType !== CELL_TYPES.EMPTY &&\r\n          cell.cellType !== CELL_TYPES.START &&\r\n          cell.cellType !== CELL_TYPES.END\r\n        ) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  resetForSearch() {\r\n    return new Promise((resolve, reject) => {\r\n      resolve(\r\n        this.resetCellsForSearch().catch((err) => {\r\n          console.log(err);\r\n          reject(err);\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  async resetCellsForSearch() {\r\n    gridCl.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  clearWalls = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        if (cell.cellType === CELL_TYPES.OBSTACLE) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  calculateDistance(cellA, cellB) {\r\n    var dstX = Math.abs(cellA.x - cellB.x);\r\n    var dstY = Math.abs(cellA.y - cellB.y);\r\n\r\n    if (dstX > dstY) {\r\n      return 14 * dstY + 10 * (dstX - dstY);\r\n    }\r\n\r\n    return 14 * dstX + 10 * (dstY - dstX);\r\n  }\r\n\r\n  outlineGrid(animTime) {\r\n    return new Promise((resolve, reject) =>\r\n      resolve(\r\n        this.outLine(animTime).catch((err) => {\r\n          console.log(err);\r\n          reject(err);\r\n        })\r\n      )\r\n    );\r\n  }\r\n  async outLine(animTime) {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      if (!cellIsStartOrEnd(0, y)) {\r\n        this.grid[y][0].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][0].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(this.maxX - 1, y)) {\r\n        this.grid[y][this.maxX - 1].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][this.maxX - 1].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n    for (let x = 0; x < this.maxX; x++) {\r\n      if (!cellIsStartOrEnd(x, 0)) {\r\n        this.grid[0][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[0][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(x, this.maxY - 1)) {\r\n        this.grid[this.maxY - 1][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[this.maxY - 1][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n  }\r\n}\r\n\r\nexport const gridCl = new GridCl();\r\n\r\nfunction Grid() {\r\n  return (\r\n    <section id=\"grid\">\r\n      {gridCl.grid.map((row) =>\r\n        row.map((cell) => {\r\n          return <CellSquareState cell={cell} key={cell.x + \" \" + cell.y} />;\r\n        })\r\n      )}\r\n    </section>\r\n  );\r\n}\r\n\r\nexport default Grid;\r\n","export default class Heap {\r\n  /*The item at the top of the heap has succeeded all the other items and has the lowest fCost */\r\n  items = [];\r\n\r\n  // the index of the last item in the heap\r\n  lastHeapItemIndex = -1;\r\n\r\n  constructor(searchType) {\r\n    this.searchType = searchType;\r\n  }\r\n\r\n  contains(item) {\r\n    // check if the heap includes a given item\r\n    return this.items.includes(item);\r\n  }\r\n\r\n  add(item) {\r\n    this.lastHeapItemIndex++;\r\n\r\n    // assign the heap index to be the last added item index\r\n    item.heapIndex = this.lastHeapItemIndex;\r\n    this.items[this.lastHeapItemIndex] = item;\r\n    this.sortUp(item);\r\n  }\r\n\r\n  removeFirst() {\r\n    let firstCell = this.items[0];\r\n\r\n    // remove the last item and make it the first\r\n    this.items[0] = this.items.pop();\r\n\r\n    // change the (was last) item's heapIndex to be 0\r\n    this.items[0].heapIndex = 0;\r\n\r\n    // since we popped a item out the lastHeapItemIndex must be decremented\r\n    this.lastHeapItemIndex--;\r\n\r\n    //sort the top item down the heap\r\n    this.sortDown(this.items[0]);\r\n\r\n    return firstCell;\r\n  }\r\n\r\n  update(item, sortUp) {\r\n    if (sortUp) {\r\n      this.sortUp(item);\r\n    } else {\r\n      this.sortDown(item);\r\n    }\r\n  }\r\n\r\n  sortUp(item) {\r\n    while (true) {\r\n      let parentIndex = Math.floor((item.heapIndex - 1) / 2);\r\n      parentIndex = parentIndex < 0 ? 0 : parentIndex;\r\n\r\n      var parentCell = this.items[parentIndex];\r\n\r\n      // if the item succeeds the parent item\r\n      if (item.compareTo(parentCell, this.searchType) > 0) {\r\n        // swap the item and parent positions in the heap\r\n        this.swap(item, parentCell);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  sortDown(item) {\r\n    // #region Explanation\r\n    /*\r\n    A* algorithm example: \r\n    we continue swapping the given cell down through the heap.\r\n\r\n    The goal is to place the cell in a position in the heap where\r\n    the parent cell is of a lower fCost and its children items\r\n    are of a higher fCost. \r\n    \r\n    To do this we check its children items and make sure the swap index \r\n    references the child with the lowest fCost. This is because we only\r\n    swap with a child that has a lower fCost then the given cell so it \r\n    makes it easier to just pick the lower fCost child.\r\n    \r\n    (If we swap with the lower fCost child we do not need to check and see if \r\n    the other child also has a fCost lower then the given cell because we have already \r\n    done a valid swap) => allows less checks\r\n    \r\n    https://www.youtube.com/watch?v=3Dw5d7PlcTM\r\n    */\r\n    //#endregion\r\n    while (true) {\r\n      var leftChildIndex = Math.floor(item.heapIndex * 2 + 1);\r\n      leftChildIndex = leftChildIndex < 0 ? 0 : leftChildIndex;\r\n\r\n      var rightChildIndex = Math.floor(item.heapIndex * 2 + 2);\r\n      rightChildIndex = rightChildIndex < 0 ? 0 : rightChildIndex;\r\n\r\n      // if the left child exists\r\n      if (leftChildIndex < this.items.length) {\r\n        var swapIndex = leftChildIndex;\r\n\r\n        // if the right child exists\r\n        if (rightChildIndex < this.items.length) {\r\n          // if the right child succeeds the left child\r\n          if (\r\n            this.items[rightChildIndex].compareTo(\r\n              this.items[leftChildIndex],\r\n              this.searchType\r\n            ) > 0\r\n          ) {\r\n            // we will be swapping with the child\r\n            swapIndex = rightChildIndex;\r\n          }\r\n        }\r\n\r\n        // if the item precedes the item to swap with\r\n        if (item.compareTo(this.items[swapIndex], this.searchType) < 0) {\r\n          // swap with the item\r\n          this.swap(item, this.items[swapIndex]);\r\n        } else {\r\n          return;\r\n        }\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  swap(itemA, itemB) {\r\n    // swap the items\r\n    this.items[itemA.heapIndex] = itemB;\r\n    this.items[itemB.heapIndex] = itemA;\r\n\r\n    let item_A_index = itemA.heapIndex;\r\n\r\n    // swap the indices\r\n    itemA.heapIndex = itemB.heapIndex;\r\n    itemB.heapIndex = item_A_index;\r\n  }\r\n}\r\n","import Heap from \"../DataStructures/Heap\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\nimport { searchVars, retracePath } from \"../Search\";\r\nimport { SEARCH_TYPES } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\n\r\nexport default async function AStarSearch(canCrossDiagonals) {\r\n  await gridCl.resetForSearch();\r\n  // create a heap that will contain any cells that we have opened\r\n  const openHeap = new Heap(SEARCH_TYPES.A_STAR);\r\n\r\n  //closed set containing the cells thats neighbours have been checked\r\n  const closedSet = new Set();\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n  openHeap.add(startCell);\r\n\r\n  var foundPath = false;\r\n\r\n  while (openHeap.lastHeapItemIndex >= 0) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    const currentCell = openHeap.removeFirst();\r\n\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    var neighbours = [];\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const neighbour = neighbours[i];\r\n      if (\r\n        neighbour.cellType === CELL_TYPES.OBSTACLE ||\r\n        closedSet.has(neighbour)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      var newCostToNeighbour =\r\n        currentCell.gCost + gridCl.calculateDistance(currentCell, neighbour);\r\n\r\n      if (\r\n        newCostToNeighbour < neighbour.gCost ||\r\n        !openHeap.contains(neighbour)\r\n      ) {\r\n        neighbour.gCost = newCostToNeighbour;\r\n        neighbour.hCost = gridCl.calculateDistance(neighbour, endCell);\r\n        neighbour.parentCell = currentCell;\r\n\r\n        if (!openHeap.contains(neighbour)) {\r\n          openHeap.add(neighbour);\r\n          neighbour.opened = true;\r\n\r\n          //rerender with the color of an opened cell\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        } else {\r\n          openHeap.update(neighbour, true);\r\n        }\r\n      }\r\n    }\r\n\r\n    //rerender with the color of a closed cell\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    closedSet.add(currentCell);\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n    return null;\r\n  }\r\n}\r\n","import { searchVars, retracePath, SEARCH_TYPES } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\nimport Heap from \"../DataStructures/Heap\";\r\n\r\nexport default async function dijkstrasSearch(canCrossDiagonals) {\r\n  /*if a cell is closed it means it has been visited, if it is not closed but is instead open\r\n    then the cells dijkstrasShortest has been assigned, but its neighbours have not been checked. \r\n    To be visited it means that cells neighbours must have been checked.*/\r\n\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  //create a heap of unvisited cells\r\n  const unvisitedHeap = new Heap(SEARCH_TYPES.DIJKSTRA);\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initHeap(unvisitedHeap);\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n  // the start cell has a cost of 0\r\n  startCell.gCost = 0;\r\n  unvisitedHeap.update(startCell, true);\r\n\r\n  var currentCell = unvisitedHeap.removeFirst();\r\n  var neighbours = [];\r\n\r\n  // continue looping until there is not unvisited cells\r\n  while (unvisitedHeap.lastHeapItemIndex >= 0) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // loop through all unvisited neighbours\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // calculate the new distance to the neighbour using the distance from the curr to the start plus the distance from the curr to the neighbour\r\n        const newDistanceFromStartToNeighbour =\r\n          tempCurrentCell.gCost +\r\n          gridCl.calculateDistance(tempCurrentCell, neighbour);\r\n\r\n        // if the newDistanceFromStartToNeighbour is smaller then the current shortest\r\n        if (neighbour.gCost > newDistanceFromStartToNeighbour) {\r\n          // assign the new shortest distance\r\n          neighbour.gCost = newDistanceFromStartToNeighbour;\r\n\r\n          // assign the parent cell of the neighbour to be the curr\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          // the neighbour has been opened so rerender\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n          // update its position in the heap\r\n          unvisitedHeap.update(neighbour, true);\r\n        }\r\n      }\r\n    });\r\n\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n\r\n    // pick the cell with the lowest distance from the start\r\n    currentCell = unvisitedHeap.removeFirst();\r\n\r\n    // if the current cell is the end then we have the shortest path\r\n    if (currentCell === endCell) {\r\n      const path = retracePath(startCell, endCell);\r\n      return path;\r\n    }\r\n    // if after picking new distances for neighbours the lowest distance cell is still max value it means there is no path.\r\n    if (currentCell.gCost === Number.MAX_SAFE_INTEGER) {\r\n      break;\r\n    }\r\n  }\r\n  console.log(\"no path found\");\r\n}\r\n\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n          heap.add(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","export default class Queue {\r\n  items = {};\r\n  head = 0;\r\n  tail = 0;\r\n\r\n  enQueue(item) {\r\n    this.items[this.tail] = item;\r\n    this.tail++;\r\n  }\r\n\r\n  deQueue() {\r\n    var size = this.tail - this.head;\r\n    if (size <= 0) return undefined;\r\n\r\n    var item = this.items[this.head];\r\n\r\n    delete this.items[this.head];\r\n\r\n    this.head++;\r\n\r\n    if (this.head === this.tail) {\r\n      this.head = 0;\r\n      this.tail = 0;\r\n    }\r\n\r\n    return item;\r\n  }\r\n\r\n  size() {\r\n    return this.tail - this.head;\r\n  }\r\n\r\n  peek() {\r\n    return this.items[this.head];\r\n  }\r\n\r\n  print() {\r\n    var result = [];\r\n    for (let key in this.items) {\r\n      result.push(this.items[key]);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\nimport Queue from \"../DataStructures/Queue\";\r\n\r\nexport default async function breadthFirstSearch(canCrossDiagonals) {\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  //create a heap of unvisited cells\r\n  const unvisitedQueue = new Queue();\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initGCosts();\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n\r\n  var currentCell = null;\r\n\r\n  var neighbours = [];\r\n  // add to the queue the start cell\r\n  startCell.opened = true;\r\n  startCell.gCost = 0;\r\n  unvisitedQueue.enQueue(startCell);\r\n\r\n  // continue looping until there is not unvisited cells\r\n  while (unvisitedQueue.size() > 0) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    // dequeue to cell to get the current cell\r\n    currentCell = unvisitedQueue.deQueue();\r\n    if (currentCell === undefined) {\r\n      // if there is nothing to dequeue then no path\r\n      break;\r\n    }\r\n\r\n    // if the current cell is the end then we have the shortest path\r\n    if (currentCell === endCell) {\r\n      const path = retracePath(startCell, endCell);\r\n      return path;\r\n    }\r\n\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n    // loop through all unvisited neighbours\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // if the neighbour is not closed or opened\r\n        if (!neighbour.closed && !neighbour.opened) {\r\n          // add neighbour to queue\r\n          unvisitedQueue.enQueue(neighbour);\r\n        }\r\n        // calculate the new distance to the neighbour using the distance from the curr to the start plus the distance from the curr to the neighbour\r\n        const newDistanceFromStartToNeighbour =\r\n          tempCurrentCell.gCost +\r\n          gridCl.calculateDistance(tempCurrentCell, neighbour);\r\n\r\n        // if the newDistanceFromStartToNeighbour is smaller then the current shortest\r\n        if (neighbour.gCost > newDistanceFromStartToNeighbour) {\r\n          // assign the new shortest distance\r\n          neighbour.gCost = newDistanceFromStartToNeighbour;\r\n\r\n          // assign the parent cell of the neighbour to be the curr\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          // the neighbour has been opened so rerender\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        }\r\n      }\r\n    });\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  console.log(\"no path found\");\r\n}\r\n\r\nfunction initGCosts() {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { searchVars, retracePath, SEARCH_TYPES } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\nimport Heap from \"../DataStructures/Heap\";\r\n\r\nexport default async function bestFirstSearch(canCrossDiagonals) {\r\n  /*if a cell is closed it means it has been visited, if it is not closed but is instead open\r\n    then the cells dijkstrasShortest has been assigned, but its neighbours have not been checked. \r\n    To be visited it means that cells neighbours must have been checked.*/\r\n\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  //create a heap of unvisited cells\r\n  const unvisitedHeap = new Heap(SEARCH_TYPES.BEST_FIRST);\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initHeap(unvisitedHeap);\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n\r\n  // the start cell has a cost of 0\r\n  startCell.hCost = gridCl.calculateDistance(startCell, endCell);\r\n  unvisitedHeap.update(startCell, true);\r\n\r\n  var currentCell = unvisitedHeap.removeFirst();\r\n\r\n  var neighbours = [];\r\n\r\n  // continue looping until there is not unvisited cells\r\n  while (unvisitedHeap.lastHeapItemIndex >= 0) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter(\r\n      (x) => !x.closed && !x.opened\r\n    );\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // loop through all unvisited neighbours\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // assign the new shortest distance\r\n        neighbour.hCost = gridCl.calculateDistance(neighbour, endCell);\r\n\r\n        // assign the parent cell of the neighbour to be the curr\r\n        neighbour.parentCell = tempCurrentCell;\r\n\r\n        // the neighbour has been opened so rerender\r\n        neighbour.opened = true;\r\n        neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n        // update its position in the heap\r\n        unvisitedHeap.update(neighbour, true);\r\n      }\r\n    });\r\n\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n\r\n    // pick the cell with the lowest distance from the start\r\n    currentCell = unvisitedHeap.removeFirst();\r\n\r\n    // if the current cell is the end then we have the shortest path\r\n    if (currentCell === endCell) {\r\n      const path = retracePath(startCell, endCell);\r\n      return path;\r\n    }\r\n    // if after picking new distances for neighbours the lowest distance cell is still max value it means there is no path.\r\n    if (currentCell.hCost === Number.MAX_SAFE_INTEGER) {\r\n      break;\r\n    }\r\n  }\r\n  console.log(\"no path found\");\r\n}\r\n\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.hCost = Number.MAX_SAFE_INTEGER;\r\n          heap.add(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { rndEven, rndOdd, timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\n\r\nconst ORIENTATIONS = {\r\n  HORIZONTAL: \"HORIZONTAL\",\r\n  VERTICAL: \"VERTICAL\",\r\n};\r\n\r\nexport default function startRecursiveDivision() {\r\n  return new Promise((resolve, reject) => {\r\n    resolve(\r\n      divide(\r\n        1,\r\n        1,\r\n        gridCl.maxX - 2, // -1 to make it indexed base and -1 again to add an outline of 1\r\n        gridCl.maxY - 2,\r\n        chooseOrientation(1, 1, gridCl.maxX - 2, gridCl.maxY - 2)\r\n      ).catch((err) => {\r\n        console.log(err);\r\n        reject(err);\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\nfunction chooseOrientation(leftBound, upperBound, rightBound, lowerBound) {\r\n  // if the horizontal space is greater than the vertical cut vertically vice-versa\r\n  const horizSpace = rightBound - leftBound;\r\n  const vertSpace = lowerBound - upperBound;\r\n  if (horizSpace > vertSpace) {\r\n    return ORIENTATIONS.VERTICAL;\r\n  } else if (vertSpace > horizSpace) {\r\n    return ORIENTATIONS.HORIZONTAL;\r\n  } else {\r\n    return Math.random() > 0.5\r\n      ? ORIENTATIONS.HORIZONTAL\r\n      : ORIENTATIONS.VERTICAL;\r\n  }\r\n}\r\n\r\nasync function divide(\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound,\r\n  orientation\r\n) {\r\n  if (rightBound - leftBound < 2 || lowerBound - upperBound < 2) {\r\n    return;\r\n  }\r\n\r\n  var isHorizontalCut = orientation === ORIENTATIONS.HORIZONTAL;\r\n\r\n  const { xStartIdx, yStartIdx } = findStart(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n\r\n  const { xPassageIdx, yPassageIdx } = choosePassage(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n  var wallDist = isHorizontalCut\r\n    ? rightBound - leftBound\r\n    : lowerBound - upperBound;\r\n  var dirX = isHorizontalCut ? 1 : 0;\r\n  var dirY = isHorizontalCut ? 0 : 1;\r\n  await drawWall(\r\n    xStartIdx,\r\n    yStartIdx,\r\n    xPassageIdx,\r\n    yPassageIdx,\r\n    wallDist,\r\n    dirX,\r\n    dirY\r\n  );\r\n\r\n  if (isHorizontalCut) {\r\n    // top section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      rightBound,\r\n      yStartIdx - 1,\r\n      chooseOrientation(leftBound, upperBound, rightBound, yStartIdx - 1)\r\n    );\r\n    // bottom section\r\n    await divide(\r\n      leftBound,\r\n      yStartIdx + 1,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, yStartIdx + 1, rightBound, lowerBound)\r\n    );\r\n  } else {\r\n    // left section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      xStartIdx - 1,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, upperBound, xStartIdx - 1, lowerBound)\r\n    );\r\n\r\n    // right section\r\n    await divide(\r\n      xStartIdx + 1,\r\n      upperBound,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(xStartIdx + 1, upperBound, rightBound, lowerBound)\r\n    );\r\n  }\r\n}\r\n\r\nasync function drawWall(\r\n  xStartIdx,\r\n  yStartIdx,\r\n  xPassageIdx,\r\n  yPassageIdx,\r\n  wallDist,\r\n  dirX,\r\n  dirY\r\n) {\r\n  var xWallIdx = xStartIdx;\r\n  var yWallIdx = yStartIdx;\r\n\r\n  for (let i = 0; i <= wallDist; i++) {\r\n    if (\r\n      xWallIdx === xPassageIdx ||\r\n      yWallIdx === yPassageIdx ||\r\n      cellIsStartOrEnd(xWallIdx, yWallIdx)\r\n    ) {\r\n      xWallIdx += dirX;\r\n      yWallIdx += dirY;\r\n      continue;\r\n    }\r\n    gridCl.grid[yWallIdx][xWallIdx].cellType = CELL_TYPES.OBSTACLE;\r\n    gridCl.grid[yWallIdx][xWallIdx].setCellRerender((rerender) => !rerender);\r\n    xWallIdx += dirX;\r\n    yWallIdx += dirY;\r\n    await timer(1);\r\n  }\r\n}\r\n\r\nfunction choosePassage(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xPassageIdx = 0;\r\n  var yPassageIdx = 0;\r\n\r\n  // must be any odd number between a range because walls are created on even numbers\r\n  if (isHorizontalCut) {\r\n    xPassageIdx = rndOdd(leftBound, rightBound);\r\n    yPassageIdx = upperBound;\r\n  } else {\r\n    xPassageIdx = leftBound;\r\n    yPassageIdx = rndOdd(upperBound, lowerBound);\r\n  }\r\n\r\n  return { xPassageIdx, yPassageIdx };\r\n}\r\n\r\nfunction findStart(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xStartIdx = 0;\r\n  var yStartIdx = 0;\r\n  if (isHorizontalCut) {\r\n    xStartIdx = leftBound;\r\n    /* a horiz wall needs to be on any random EVEN column because the lowerBound - 1 and\r\n    upperBound + 1 are both EVEN inclusive ranges with a grid whose Y-axis length is ODD\r\n    and an outline of 1 is applied */\r\n    yStartIdx = rndEven(upperBound + 1, lowerBound - 1);\r\n  } else {\r\n    /* a vert wall needs to be on any random EVEN row because the rightBound - 1 and\r\n    leftBound + 1 are both EVEN inclusive ranges with a grid whose X-axis length is \r\n    ODD and an outline of 1 is applied */\r\n    xStartIdx = rndEven(leftBound + 1, rightBound - 1);\r\n    yStartIdx = upperBound;\r\n  }\r\n\r\n  return { xStartIdx, yStartIdx };\r\n}\r\n","import React, { useReducer, useState } from \"react\";\r\nimport {\r\n  Alert,\r\n  Button,\r\n  Col,\r\n  Container,\r\n  Form,\r\n  FormControl,\r\n  InputGroup,\r\n  Row,\r\n} from \"react-bootstrap\";\r\nimport AStarSearch from \"../PathFindingAlgos/AStarAlgorithm\";\r\nimport dijkstrasSearch from \"../PathFindingAlgos/DijkstrasAlgorithm\";\r\nimport breadthFirstSearch from \"../PathFindingAlgos/BreadthFirstSearch\";\r\nimport bestFirstSearch from \"../PathFindingAlgos/BestFirstSearch\";\r\nimport startRecursiveDivision from \"../MazeAlgos/RecursiveDivision\";\r\nimport { searchVars, pathFind } from \"../Search\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { mazeVars, createMaze } from \"../Maze\";\r\nimport algoReducer, { initialState } from \"../AlgorithmReducer\";\r\nimport { clamp } from \"../UtilityFuncs\";\r\nimport \"./header.css\";\r\n\r\nfunction Header() {\r\n  const [state, dispatch] = useReducer(algoReducer, initialState);\r\n\r\n  const [canCrossDiagonals, setCanCrossDiagonals] = useState(true);\r\n  const [animationInterval, setAnimationInterval] = useState(15);\r\n  const [missingCell, setMissingCell] = useState(false);\r\n\r\n  const executePathFinding = (algorithm) => {\r\n    if (gridCl.startCell != null && gridCl.endCell != null) {\r\n      pathFind(canCrossDiagonals, dispatch, algorithm);\r\n    } else {\r\n      setMissingCell(true);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Container id=\"header\" className=\"py-3\" fluid>\r\n      <Row className=\"unselectable\">\r\n        <Col>\r\n          <InputGroup className=\"mt-3\">\r\n            <InputGroup.Prepend>\r\n              <InputGroup.Text id=\"prepending-text\">\r\n                Animation Interval (ms)\r\n              </InputGroup.Text>\r\n            </InputGroup.Prepend>\r\n            <FormControl\r\n              id=\"basic-number\"\r\n              aria-describedby=\"prepending-text\"\r\n              value={animationInterval}\r\n              onChange={(evt) => {\r\n                if (evt.target.value !== \"\") {\r\n                  let interval = clamp(\r\n                    parseFloat(evt.target.value),\r\n                    searchVars.minSearchTime,\r\n                    searchVars.maxSearchTime\r\n                  );\r\n                  setAnimationInterval(interval);\r\n                  searchVars.searchAnimationTime = interval;\r\n                }\r\n              }}\r\n              min={searchVars.minSearchTime}\r\n              max={searchVars.maxSearchTime}\r\n              step=\"50\"\r\n              type=\"number\"\r\n            />\r\n          </InputGroup>\r\n        </Col>\r\n        <Col className=\"can-cross-diagonals\">\r\n          <Form>\r\n            <Form.Check\r\n              type=\"switch\"\r\n              id=\"custom-switch\"\r\n              label=\"Can Cross Diagonals\"\r\n              checked={canCrossDiagonals}\r\n              onChange={() =>\r\n                setCanCrossDiagonals((canCrossDiagonals) => !canCrossDiagonals)\r\n              }\r\n            />\r\n          </Form>\r\n        </Col>\r\n        <Col xs={4} className=\"algorithms\">\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => createMaze(startRecursiveDivision, dispatch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Create Maze\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(AStarSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            A*\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(dijkstrasSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Dijkstras\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(breadthFirstSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Breadth First Search\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(bestFirstSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Best First Search\r\n          </Button>\r\n        </Col>\r\n        <Col className=\"clears\">\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (!searchVars.isSearching && !mazeVars.isCreatingMaze) {\r\n                gridCl.clearEntireGrid();\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Clear Entire Grid\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (!mazeVars.isCreatingMaze) {\r\n                gridCl.clearWalls();\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={state.isCreatingMaze ? \"disabled\" : \"\"}\r\n          >\r\n            Clear Walls\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (searchVars.isSearching) {\r\n                searchVars.stopSearch = true;\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={state.isSearching ? \"\" : \"disabled\"}\r\n          >\r\n            Stop Search\r\n          </Button>\r\n        </Col>\r\n        <Col xs={2}>\r\n          <p>\r\n            <b>Ctrl Click:</b> set start cell\r\n          </p>\r\n          <p>\r\n            <b>Alt Click:</b> set end cell\r\n          </p>\r\n        </Col>\r\n      </Row>\r\n      {missingCell ? (\r\n        <Alert\r\n          variant={\"danger\"}\r\n          onClose={() => setMissingCell(false)}\r\n          dismissible\r\n        >\r\n          <Alert.Heading>You are missing a start or end cell</Alert.Heading>\r\n        </Alert>\r\n      ) : (\r\n        <div></div>\r\n      )}\r\n    </Container>\r\n  );\r\n}\r\n\r\nexport default Header;\r\n","import Grid from \"./Grid/Grid\";\nimport Header from \"./Header/Header\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}