{"version":3,"sources":["AlgorithmReducer.js","Maze.js","UtilityFuncs.js","Search.js","Cell/CellActions.js","Cell/Cell.js","Grid/Grid.js","PathFindingAlgos/AStarAlgorithm.js","PathFindingAlgos/DijkstrasAlgorithm.js","DataStructures/Queue.js","PathFindingAlgos/BreadthFirstSearch.js","PathFindingAlgos/BestFirstSearch.js","MazeAlgos/RecursiveDivision.js","Header/Header.js","App.js","index.js"],"names":["ALGO_ACTIONS","initialState","isSearching","isCreatingMaze","algoReducer","state","action","type","payload","console","error","mazeVars","mazeAlgo","varDispatch","a","searchVars","gridCl","clearEntireGrid","outlineGrid","then","timer","ms","Promise","resolve","setTimeout","rnd","min","max","Math","floor","random","rndEven","rndOdd","stopSearch","maxSearchTime","minSearchTime","pathAnimationTime","searchAnimationTime","retracePath","start","end","path","currentCell","push","parentCell","reverse","canCrossDiagonals","search","searching","i","length","cell","isOnPath","setCellRerender","rerender","reject","catch","err","log","CELL_TYPES","cellIsStartOrEnd","posX","posY","grid","startCell","endCell","determineCellType","evt","mouseDown","cellTypeOnMouseDown","cellType","altKey","ctrlKey","x","y","closed","opened","changeCellType","compareAStarCells","b","comparison","fCost","hCost","compareDijkstrasCells","gCost","compareBestFirstCells","Cell","heapIndex","getCellColor","Error","this","CellSquareState","props","useState","useEffect","rerenderCell","document","onmousedown","onmouseup","CellSquare","cellClass","setCellClass","className","style","backgroundColor","onMouseMove","onMouseDown","onMouseEnter","onMouseLeave","onClick","assignFinishOrStart","maxY","maxX","initGrid","row","getMooreNeighbours","neighbours","cellIsInGrid","getVonNeumannNeighbours","forEach","clearWalls","resetCellsForSearch","cellA","cellB","dstX","abs","dstY","animTime","outLine","Grid","id","map","AStarSearch","resetForSearch","Heap","require","openHeap","closedSet","Set","foundPath","empty","pop","neighbour","has","newCostToNeighbour","calculateDistance","updateItem","add","dijkstrasSearch","unvisitedHeap","initHeap","unVisitedNeighbours","filter","tempCurrentCell","newDistanceFromStartToNeighbour","Number","MAX_SAFE_INTEGER","heap","Queue","items","head","tail","item","Object","values","indexOf","result","key","breadthFirstSearch","unvisitedQueue","initGCosts","enQueue","size","undefined","deQueue","bestFirstSearch","ORIENTATIONS","startRecursiveDivision","divide","chooseOrientation","leftBound","upperBound","rightBound","lowerBound","horizSpace","vertSpace","orientation","findStart","isHorizontalCut","xStartIdx","yStartIdx","choosePassage","xPassageIdx","yPassageIdx","wallDist","dirX","dirY","drawWall","xWallIdx","yWallIdx","Header","useReducer","dispatch","setCanCrossDiagonals","animationInterval","setAnimationInterval","missingCell","setMissingCell","executePathFinding","algorithm","pathFind","Container","fluid","Row","Col","InputGroup","Prepend","Text","FormControl","aria-describedby","value","onChange","target","interval","num","parseFloat","Form","Check","label","checked","xs","Button","variant","createMaze","Alert","onClose","dismissible","Heading","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.cdd4d89c.chunk.js","sourcesContent":["export const ALGO_ACTIONS = {\r\n  IS_SEARCHING: \"IS_SEARCHING\",\r\n  IS_CREATING_MAZE: \"IS_CREATING_MAZE\",\r\n};\r\n\r\nexport const initialState = {\r\n  isSearching: false,\r\n  isCreatingMaze: false,\r\n};\r\n\r\nexport default function algoReducer(state, action) {\r\n  switch (action.type) {\r\n    case ALGO_ACTIONS.IS_SEARCHING:\r\n      return {\r\n        ...state,\r\n        isSearching: action.payload,\r\n      };\r\n    case ALGO_ACTIONS.IS_CREATING_MAZE:\r\n      return {\r\n        ...state,\r\n        isCreatingMaze: action.payload,\r\n      };\r\n    default:\r\n      console.error(\"no matching action types\");\r\n  }\r\n}\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { gridCl } from \"./Grid/Grid\";\r\nimport { searchVars } from \"./Search\";\r\n\r\nexport const mazeVars = { isCreatingMaze: false };\r\n\r\nexport async function createMaze(mazeAlgo, varDispatch) {\r\n  if (!mazeVars.isCreatingMaze && !searchVars.isSearching) {\r\n    mazeVars.isCreatingMaze = true;\r\n    varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: true });\r\n    gridCl.clearEntireGrid();\r\n    await gridCl.outlineGrid(1).then(() => {\r\n      mazeAlgo().then(() => {\r\n        mazeVars.isCreatingMaze = false;\r\n        varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: false });\r\n      });\r\n    });\r\n  }\r\n}\r\n","export const timer = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nexport const getKeyByValue = (object, value) => {\r\n  return Object.keys(object).find((key) => object[key] === value);\r\n};\r\n\r\nexport const rnd = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nexport const rndEven = (min, max) => {\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2;\r\n  return randomNum;\r\n};\r\n\r\nexport const rndOdd = (min, max) => {\r\n  max = max % 2 === 0 ? max : max - 1;\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2 + 1;\r\n  return randomNum;\r\n};\r\n\r\nexport const clamp = (num, min, max) => Math.min(Math.max(num, min), max);\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { mazeVars } from \"./Maze\";\r\nimport { timer } from \"./UtilityFuncs\";\r\n\r\nexport const searchVars = {\r\n  isSearching: false,\r\n  stopSearch: false,\r\n  maxSearchTime: 3000,\r\n  minSearchTime: 1,\r\n  pathAnimationTime: 10,\r\n  searchAnimationTime: 15,\r\n};\r\n\r\nexport function retracePath(start, end) {\r\n  const path = [];\r\n  var currentCell = end;\r\n\r\n  while (currentCell !== start) {\r\n    path.push(currentCell);\r\n    currentCell = currentCell.parentCell;\r\n  }\r\n  path.reverse();\r\n\r\n  return path;\r\n}\r\n\r\nexport async function pathFind(canCrossDiagonals, varDispatch, search) {\r\n  // lock the async function so it can only run one at a time\r\n  if (searchVars.isSearching || mazeVars.isCreatingMaze) {\r\n    return;\r\n  }\r\n  searchVars.isSearching = true;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: true });\r\n  //search for the path\r\n  await searching(canCrossDiagonals, search).then(async (path) => {\r\n    if (path == null) {\r\n      searchVars.isSearching = false;\r\n      searchVars.stopSearch = false;\r\n      varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: false });\r\n      return;\r\n    }\r\n    //draw the path\r\n    for (let i = 0; i < path.length; i++) {\r\n      const cell = path[i];\r\n      cell.isOnPath = true;\r\n      cell.setCellRerender((rerender) => !rerender);\r\n      await timer(searchVars.pathAnimationTime);\r\n    }\r\n  });\r\n  searchVars.isSearching = false;\r\n  searchVars.stopSearch = false;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: false });\r\n}\r\n\r\nfunction searching(canCrossDiagonals, search) {\r\n  return new Promise((resolve, reject) => {\r\n    resolve(\r\n      search(canCrossDiagonals).catch((err) => {\r\n        console.log(err);\r\n        reject(err);\r\n      })\r\n    );\r\n  });\r\n}\r\n","import { gridCl } from \"../Grid/Grid\";\r\nimport { searchVars } from \"../Search\";\r\n\r\nexport const CELL_TYPES = {\r\n  EMPTY: 0,\r\n  START: 1,\r\n  END: 2,\r\n  OBSTACLE: 3,\r\n};\r\n\r\nexport const assignFinishOrStart = (evt, cell) => {\r\n  if (evt.altKey) {\r\n    // if the cell is the end cell\r\n    if (cell.cellType === CELL_TYPES.END) {\r\n      gridCl.endCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      // if the start cell is this cell\r\n      if (cell.cellType === CELL_TYPES.START) {\r\n        // empty the start cell\r\n        gridCl.startCell = null;\r\n      }\r\n      // if there is a end cell\r\n      if (gridCl.endCell != null) {\r\n        // empty the end cell\r\n        changeCellType(gridCl.endCell, CELL_TYPES.EMPTY);\r\n      }\r\n      // change the end cell to be this cell\r\n      changeCellType(cell, CELL_TYPES.END);\r\n      gridCl.endCell = cell;\r\n    }\r\n  } else if (evt.ctrlKey) {\r\n    // if the cell is the start cell then make it empty\r\n    if (cell.cellType === CELL_TYPES.START) {\r\n      gridCl.startCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      // if the cell type is the end\r\n      if (cell.cellType === CELL_TYPES.END) {\r\n        // empty the end cell\r\n        gridCl.endCell = null;\r\n      }\r\n\r\n      // if there is a start cell\r\n      if (gridCl.startCell != null) {\r\n        // empty it\r\n        changeCellType(gridCl.startCell, CELL_TYPES.EMPTY);\r\n      }\r\n      // make this cell the start\r\n      changeCellType(cell, CELL_TYPES.START);\r\n      gridCl.startCell = cell;\r\n    }\r\n  }\r\n};\r\n\r\nexport const cellIsStartOrEnd = (posX, posY) => {\r\n  return (\r\n    gridCl.grid[posY][posX] === gridCl.startCell ||\r\n    gridCl.grid[posY][posX] === gridCl.endCell\r\n  );\r\n};\r\n\r\nexport const determineCellType = (\r\n  evt,\r\n  mouseDown,\r\n  cellTypeOnMouseDown,\r\n  cell\r\n) => {\r\n  if (mouseDown) {\r\n    if (cellTypeOnMouseDown === -1) return;\r\n    const cellType =\r\n      cellTypeOnMouseDown === CELL_TYPES.EMPTY\r\n        ? CELL_TYPES.OBSTACLE\r\n        : CELL_TYPES.EMPTY;\r\n    if (cell.cellType !== cellType && !evt.altKey && !evt.ctrlKey) {\r\n      if (cellIsStartOrEnd(cell.x, cell.y)) {\r\n        return;\r\n      }\r\n      if ((cell.closed || cell.opened) && searchVars.isSearching) {\r\n        return;\r\n      }\r\n      changeCellType(cell, cellType);\r\n    }\r\n  }\r\n};\r\n\r\nconst changeCellType = (cell, cellType) => {\r\n  cell.cellType = cellType;\r\n  cell.setCellRerender((rerender) => !rerender);\r\n};\r\n\r\nexport function compareAStarCells(a, b) {\r\n  // if the fcost is smaller then the other cells fcost then it succeeds otherwise it precedes\r\n  var comparison = a.fCost() < b.fCost() ? -1 : 1;\r\n\r\n  // if the fCosts are equal\r\n  if (a.fCost() === b.fCost()) {\r\n    // if the hcost is smaller then the other cells hcost then it succeeds otherwise it is equal\r\n    comparison = a.hCost < b.hCost ? -1 : 0;\r\n  }\r\n\r\n  return comparison;\r\n}\r\n\r\nexport function compareDijkstrasCells(a, b) {\r\n  var comparison = a.gCost < b.gCost ? -1 : 1;\r\n  if (a.gCost === b.gCost) {\r\n    comparison = 0;\r\n  }\r\n  return comparison;\r\n}\r\n\r\nexport function compareBestFirstCells(a, b) {\r\n  var comparison = a.hCost < b.hCost ? -1 : 1;\r\n  if (a.hCost === b.hCost) {\r\n    comparison = 0;\r\n  }\r\n  return comparison;\r\n}\r\n","import React, { useEffect, useState } from \"react\";\r\nimport {\r\n  assignFinishOrStart,\r\n  determineCellType,\r\n  CELL_TYPES,\r\n} from \"./CellActions\";\r\nimport \"./cell.css\";\r\n\r\nexport default class Cell {\r\n  setCellRerender = null;\r\n  isOnPath = false;\r\n  opened = false;\r\n  closed = false;\r\n  cellType = CELL_TYPES.EMPTY;\r\n\r\n  // #region A* path finding\r\n\r\n  // the cost from this cell to the start cell\r\n  gCost = 0;\r\n  // the cost from this cell to the end cell\r\n  hCost = 0;\r\n\r\n  // the total cost\r\n  fCost = () => this.hCost + this.gCost;\r\n  // #endregion\r\n\r\n  // the index in the heap\r\n  heapIndex = -1;\r\n\r\n  // the referenced parent cell for backtracking and finding the path\r\n  parentCell = null;\r\n\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  getCellColor = () => {\r\n    if (\r\n      (!this.opened && !this.isOnPath && !this.closed) ||\r\n      this.cellType !== 0\r\n    ) {\r\n      switch (this.cellType) {\r\n        case CELL_TYPES.EMPTY:\r\n          return \"rgba(221, 221, 221, 0.603)\";\r\n        case CELL_TYPES.START:\r\n          return \"green\";\r\n        case CELL_TYPES.END:\r\n          return \"red\";\r\n        case CELL_TYPES.OBSTACLE:\r\n          return \"black\";\r\n        default:\r\n          throw new Error(\"Out of range exception\");\r\n      }\r\n    } else if (this.isOnPath) {\r\n      return \"lightskyblue\";\r\n    } else if (this.closed) {\r\n      return \"lightgray\";\r\n    } else if (this.opened) {\r\n      return \"lightgreen\";\r\n    }\r\n  };\r\n}\r\n\r\nvar mouseDown = false;\r\nvar cellTypeOnMouseDown = -1;\r\n\r\nexport function CellSquareState(props) {\r\n  const { cell } = props;\r\n  const [, setCellRerender] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (cell.rerenderCell == null) {\r\n      cell.setCellRerender = setCellRerender;\r\n    }\r\n  }, [cell]);\r\n\r\n  document.onmousedown = () => (mouseDown = true);\r\n\r\n  document.onmouseup = () => {\r\n    mouseDown = false;\r\n    cellTypeOnMouseDown = -1;\r\n  };\r\n\r\n  return <CellSquare state={{ cell }} />;\r\n}\r\n\r\nfunction CellSquare({ state }) {\r\n  const { cell } = state;\r\n  const [cellClass, setCellClass] = useState(\"load-cell\");\r\n  return (\r\n    <div\r\n      className={cellClass}\r\n      style={{ backgroundColor: cell.getCellColor() }}\r\n      onMouseMove={(evt) =>\r\n        determineCellType(evt, mouseDown, cellTypeOnMouseDown, cell)\r\n      }\r\n      onMouseDown={(evt) => {\r\n        cellTypeOnMouseDown = cell.cellType;\r\n        determineCellType(evt, true, cellTypeOnMouseDown, cell);\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (cellClass !== \"cell-hovered\") {\r\n          setCellClass(\"cell-hovered\");\r\n        }\r\n      }}\r\n      onMouseLeave={() => {\r\n        if (cellClass !== \"cell-unhovered\") {\r\n          setCellClass(\"cell-unhovered\");\r\n        }\r\n      }}\r\n      onClick={(evt) => assignFinishOrStart(evt, cell)}\r\n    ></div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport Cell, { CellSquareState } from \"../Cell/Cell\";\r\nimport { CELL_TYPES, cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport \"./grid.css\";\r\n\r\nclass GridCl {\r\n  grid = [];\r\n  startCell = null;\r\n  endCell = null;\r\n  // dims must be odd to work with recursive division\r\n  maxY = 27; // 27\r\n  maxX = 61; // 61\r\n\r\n  constructor() {\r\n    this.initGrid();\r\n  }\r\n  initGrid = () => {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      var row = [];\r\n      for (let x = 0; x < this.maxX; x++) {\r\n        row.push(new Cell(x, y));\r\n      }\r\n      this.grid.push(row);\r\n    }\r\n\r\n    let startCell = this.grid[Math.floor(this.maxY / 2)][\r\n      Math.floor(this.maxX / 4)\r\n    ];\r\n    let endCell = this.grid[Math.floor(this.maxY / 2)][\r\n      Math.floor(this.maxX - this.maxX / 4)\r\n    ];\r\n\r\n    startCell.cellType = CELL_TYPES.START;\r\n    endCell.cellType = CELL_TYPES.END;\r\n\r\n    this.startCell = startCell;\r\n    this.endCell = endCell;\r\n  };\r\n\r\n  getMooreNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n    for (var y = -1; y <= 1; y++) {\r\n      for (var x = -1; x <= 1; x++) {\r\n        if (x === 0 && y === 0) {\r\n          continue;\r\n        }\r\n        if (!this.cellIsInGrid(posX + x, posY + y)) {\r\n          continue;\r\n        }\r\n\r\n        neighbours.push(this.grid[posY + y][posX + x]);\r\n      }\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  getVonNeumannNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n\r\n    if (this.cellIsInGrid(posX - 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX - 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX + 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX + 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY - 1)) {\r\n      neighbours.push(this.grid[posY - 1][posX]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY + 1)) {\r\n      neighbours.push(this.grid[posY + 1][posX]);\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  cellIsInGrid = (x, y) => {\r\n    if (x < 0 || y < 0 || x >= this.maxX || y >= this.maxY) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  clearEntireGrid = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (\r\n          cell.cellType !== CELL_TYPES.EMPTY &&\r\n          cell.cellType !== CELL_TYPES.START &&\r\n          cell.cellType !== CELL_TYPES.END\r\n        ) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  resetForSearch() {\r\n    return new Promise((resolve, reject) => {\r\n      resolve(\r\n        this.resetCellsForSearch().catch((err) => {\r\n          console.log(err);\r\n          reject(err);\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  async resetCellsForSearch() {\r\n    gridCl.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  clearWalls = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        if (cell.cellType === CELL_TYPES.OBSTACLE) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  calculateDistance(cellA, cellB, canCrossDiagonals) {\r\n    if (canCrossDiagonals) {\r\n      var dstX = Math.abs(cellA.x - cellB.x);\r\n      var dstY = Math.abs(cellA.y - cellB.y);\r\n\r\n      if (dstX > dstY) {\r\n        return 14 * dstY + 10 * (dstX - dstY);\r\n      }\r\n\r\n      return 14 * dstX + 10 * (dstY - dstX);\r\n    } else {\r\n      return Math.abs(cellA.x - cellB.x) + Math.abs(cellA.y - cellB.y);\r\n    }\r\n  }\r\n\r\n  outlineGrid(animTime) {\r\n    return new Promise((resolve, reject) =>\r\n      resolve(\r\n        this.outLine(animTime).catch((err) => {\r\n          console.log(err);\r\n          reject(err);\r\n        })\r\n      )\r\n    );\r\n  }\r\n  async outLine(animTime) {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      if (!cellIsStartOrEnd(0, y)) {\r\n        this.grid[y][0].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][0].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(this.maxX - 1, y)) {\r\n        this.grid[y][this.maxX - 1].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][this.maxX - 1].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n    for (let x = 0; x < this.maxX; x++) {\r\n      if (!cellIsStartOrEnd(x, 0)) {\r\n        this.grid[0][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[0][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(x, this.maxY - 1)) {\r\n        this.grid[this.maxY - 1][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[this.maxY - 1][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n  }\r\n}\r\n\r\nexport const gridCl = new GridCl();\r\n\r\nfunction Grid() {\r\n  return (\r\n    <section id=\"grid\">\r\n      {gridCl.grid.map((row) =>\r\n        row.map((cell) => {\r\n          return <CellSquareState cell={cell} key={cell.x + \" \" + cell.y} />;\r\n        })\r\n      )}\r\n    </section>\r\n  );\r\n}\r\n\r\nexport default Grid;\r\n","// import Heap from \"../DataStructures/Heap\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareAStarCells } from \"../Cell/CellActions\";\r\nimport { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\n\r\nexport default async function AStarSearch(canCrossDiagonals) {\r\n  await gridCl.resetForSearch();\r\n  // create a heap that will contain any cells that we have opened\r\n  var Heap = require(\"heap\");\r\n  const openHeap = new Heap(compareAStarCells);\r\n\r\n  //closed set containing the cells thats neighbours have been checked\r\n  const closedSet = new Set();\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n  openHeap.push(startCell);\r\n  var foundPath = false;\r\n\r\n  while (!openHeap.empty()) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    const currentCell = openHeap.pop();\r\n\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    var neighbours = [];\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const neighbour = neighbours[i];\r\n      if (\r\n        neighbour.cellType === CELL_TYPES.OBSTACLE ||\r\n        closedSet.has(neighbour)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      var newCostToNeighbour =\r\n        currentCell.gCost +\r\n        gridCl.calculateDistance(currentCell, neighbour, canCrossDiagonals);\r\n\r\n      if (newCostToNeighbour < neighbour.gCost || !neighbour.opened) {\r\n        neighbour.gCost = newCostToNeighbour;\r\n        neighbour.hCost = gridCl.calculateDistance(\r\n          neighbour,\r\n          endCell,\r\n          canCrossDiagonals\r\n        );\r\n        neighbour.parentCell = currentCell;\r\n\r\n        if (!neighbour.opened) {\r\n          openHeap.push(neighbour);\r\n          neighbour.opened = true;\r\n\r\n          //rerender with the color of an opened cell\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        } else {\r\n          openHeap.updateItem(neighbour);\r\n        }\r\n      }\r\n    }\r\n\r\n    //rerender with the color of a closed cell\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    closedSet.add(currentCell);\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n    return null;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareDijkstrasCells } from \"../Cell/CellActions\";\r\n\r\nexport default async function dijkstrasSearch(canCrossDiagonals) {\r\n  /*if a cell is closed it means it has been visited, if it is not closed but is instead open\r\n    then the cells dijkstrasShortest has been assigned, but its neighbours have not been checked. \r\n    To be visited it means that cells neighbours must have been checked.*/\r\n\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  var Heap = require(\"heap\");\r\n\r\n  //create a heap of unvisited cells\r\n  const unvisitedHeap = new Heap(compareDijkstrasCells);\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initHeap(unvisitedHeap);\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n  // the start cell has a cost of 0\r\n  startCell.gCost = 0;\r\n  unvisitedHeap.updateItem(startCell);\r\n\r\n  var currentCell = unvisitedHeap.pop();\r\n  var neighbours = [];\r\n  var foundPath = false;\r\n\r\n  // continue looping until there is not unvisited cells\r\n  while (!unvisitedHeap.empty()) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // loop through all unvisited neighbours\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // calculate the new distance to the neighbour using the distance from the curr to the start plus the distance from the curr to the neighbour\r\n        const newDistanceFromStartToNeighbour =\r\n          tempCurrentCell.gCost +\r\n          gridCl.calculateDistance(\r\n            tempCurrentCell,\r\n            neighbour,\r\n            canCrossDiagonals\r\n          );\r\n\r\n        // if the newDistanceFromStartToNeighbour is smaller then the current shortest\r\n        if (neighbour.gCost > newDistanceFromStartToNeighbour) {\r\n          // assign the new shortest distance\r\n          neighbour.gCost = newDistanceFromStartToNeighbour;\r\n\r\n          // assign the parent cell of the neighbour to be the curr\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          // the neighbour has been opened so rerender\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n          // update its position in the heap\r\n          unvisitedHeap.updateItem(neighbour);\r\n        }\r\n      }\r\n    });\r\n\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n\r\n    // pick the cell with the lowest distance from the start\r\n    currentCell = unvisitedHeap.pop();\r\n\r\n    // if after picking new distances for neighbours the lowest distance cell is still max value it means there is no path.\r\n    if (currentCell.gCost === Number.MAX_SAFE_INTEGER) {\r\n      break;\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  }\r\n  console.log(\"no path found\");\r\n}\r\n\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n          heap.push(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","export default class Queue {\r\n  items = {};\r\n  head = 0;\r\n  tail = 0;\r\n\r\n  enQueue(item) {\r\n    this.items[this.tail] = item;\r\n    this.tail++;\r\n  }\r\n\r\n  contains(item) {\r\n    return Object.values(this.items).indexOf(item) > -1 ? true : false;\r\n  }\r\n\r\n  deQueue() {\r\n    var size = this.tail - this.head;\r\n    if (size <= 0) return undefined;\r\n\r\n    var item = this.items[this.head];\r\n\r\n    delete this.items[this.head];\r\n\r\n    this.head++;\r\n\r\n    if (this.head === this.tail) {\r\n      this.head = 0;\r\n      this.tail = 0;\r\n    }\r\n\r\n    return item;\r\n  }\r\n\r\n  size() {\r\n    return this.tail - this.head;\r\n  }\r\n\r\n  peek() {\r\n    return this.items[this.head];\r\n  }\r\n\r\n  print() {\r\n    var result = [];\r\n    for (let key in this.items) {\r\n      result.push(this.items[key]);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\nimport Queue from \"../DataStructures/Queue\";\r\n\r\nexport default async function breadthFirstSearch(canCrossDiagonals) {\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  //create a heap of unvisited cells\r\n  const unvisitedQueue = new Queue();\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initGCosts();\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n\r\n  var currentCell = null;\r\n\r\n  var neighbours = [];\r\n  // add to the queue the start cell\r\n  startCell.opened = true;\r\n  startCell.gCost = 0;\r\n  unvisitedQueue.enQueue(startCell);\r\n  var foundPath = false;\r\n\r\n  // continue looping until there is not unvisited cells\r\n  while (unvisitedQueue.size() > 0) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    // dequeue to cell to get the current cell\r\n    currentCell = unvisitedQueue.deQueue();\r\n    if (currentCell === undefined) {\r\n      // if there is nothing to dequeue then no path\r\n      break;\r\n    }\r\n\r\n    // if the current cell is the end then we have the shortest path\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // loop through all unvisited neighbours\r\n    for (let i = 0; i < unVisitedNeighbours.length; i++) {\r\n      var neighbour = unVisitedNeighbours[i];\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // if the neighbour is not closed or opened\r\n        if (!neighbour.closed && !neighbour.opened) {\r\n          // add neighbour to queue\r\n          unvisitedQueue.enQueue(neighbour);\r\n        }\r\n        // calculate the new distance to the neighbour using the distance from the curr to the start plus the distance from the curr to the neighbour\r\n        const newDistanceFromStartToNeighbour =\r\n          tempCurrentCell.gCost +\r\n          gridCl.calculateDistance(\r\n            tempCurrentCell,\r\n            neighbour,\r\n            canCrossDiagonals\r\n          );\r\n\r\n        // if the newDistanceFromStartToNeighbour is smaller then the current shortest\r\n        if (neighbour.gCost > newDistanceFromStartToNeighbour) {\r\n          // assign the new shortest distance\r\n          neighbour.gCost = newDistanceFromStartToNeighbour;\r\n\r\n          // assign the parent cell of the neighbour to be the curr\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          // the neighbour has been opened so rerender\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        }\r\n      }\r\n    }\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n  }\r\n}\r\n\r\nfunction initGCosts() {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareBestFirstCells } from \"../Cell/CellActions\";\r\n\r\nexport default async function bestFirstSearch(canCrossDiagonals) {\r\n  /*if a cell is closed it means it has been visited, if it is not closed but is instead open\r\n    then the cells dijkstrasShortest has been assigned, but its neighbours have not been checked. \r\n    To be visited it means that cells neighbours must have been checked.*/\r\n\r\n  // reset the entire grid to prepare for the search\r\n  await gridCl.resetForSearch();\r\n  // init start and end cells\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n  var Heap = require(\"heap\");\r\n  //create a heap of unvisited cells\r\n  const unvisitedHeap = new Heap(compareBestFirstCells);\r\n  // initialize the heap with all the cells as they all start unvisited\r\n  await initHeap(unvisitedHeap);\r\n\r\n  // the parent cell of the start cell is itself for retracing purposes\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n\r\n  // the start cell has a cost of 0\r\n  startCell.hCost = gridCl.calculateDistance(\r\n    startCell,\r\n    endCell,\r\n    canCrossDiagonals\r\n  );\r\n  unvisitedHeap.updateItem(startCell);\r\n\r\n  var neighbours = [];\r\n  var foundPath = false;\r\n  // continue looping until there is not unvisited cells\r\n  while (!unvisitedHeap.empty()) {\r\n    var currentCell = unvisitedHeap.pop();\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    // check certain neigbours depending on if it can cross diagonals or not\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // filter out any visited neighbours\r\n    const unVisitedNeighbours = neighbours.filter(\r\n      (x) => !x.closed && !x.opened\r\n    );\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // loop through all unvisited neighbours\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      // only check if neighbour is not an obstacle\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // assign the new shortest distance\r\n        neighbour.hCost = gridCl.calculateDistance(\r\n          neighbour,\r\n          endCell,\r\n          canCrossDiagonals\r\n        );\r\n\r\n        // assign the parent cell of the neighbour to be the curr\r\n        neighbour.parentCell = tempCurrentCell;\r\n\r\n        // the neighbour has been opened so rerender\r\n        neighbour.opened = true;\r\n        neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n        // update its position in the heap\r\n        unvisitedHeap.updateItem(neighbour);\r\n      }\r\n    });\r\n\r\n    // set the current cell to be closed as its neighbours have been checked and rerender\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    // animation interval\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n    // if after picking new distances for neighbours the lowest distance cell is still max value it means there is no path.\r\n    if (currentCell.hCost === Number.MAX_SAFE_INTEGER) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // if we found a path retrace it\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n  }\r\n}\r\n\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.hCost = Number.MAX_SAFE_INTEGER;\r\n          heap.push(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { rndEven, rndOdd, timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\n\r\nconst ORIENTATIONS = {\r\n  HORIZONTAL: \"HORIZONTAL\",\r\n  VERTICAL: \"VERTICAL\",\r\n};\r\n\r\nexport default function startRecursiveDivision() {\r\n  return new Promise((resolve, reject) => {\r\n    resolve(\r\n      divide(\r\n        1,\r\n        1,\r\n        gridCl.maxX - 2, // -1 to make it indexed base and -1 again to add an outline of 1\r\n        gridCl.maxY - 2,\r\n        chooseOrientation(1, 1, gridCl.maxX - 2, gridCl.maxY - 2)\r\n      ).catch((err) => {\r\n        console.log(err);\r\n        reject(err);\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\nfunction chooseOrientation(leftBound, upperBound, rightBound, lowerBound) {\r\n  // if the horizontal space is greater than the vertical cut vertically vice-versa\r\n  const horizSpace = rightBound - leftBound;\r\n  const vertSpace = lowerBound - upperBound;\r\n  if (horizSpace > vertSpace) {\r\n    return ORIENTATIONS.VERTICAL;\r\n  } else if (vertSpace > horizSpace) {\r\n    return ORIENTATIONS.HORIZONTAL;\r\n  } else {\r\n    return Math.random() > 0.5\r\n      ? ORIENTATIONS.HORIZONTAL\r\n      : ORIENTATIONS.VERTICAL;\r\n  }\r\n}\r\n\r\nasync function divide(\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound,\r\n  orientation\r\n) {\r\n  if (rightBound - leftBound < 2 || lowerBound - upperBound < 2) {\r\n    return;\r\n  }\r\n\r\n  var isHorizontalCut = orientation === ORIENTATIONS.HORIZONTAL;\r\n\r\n  const { xStartIdx, yStartIdx } = findStart(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n\r\n  const { xPassageIdx, yPassageIdx } = choosePassage(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n  var wallDist = isHorizontalCut\r\n    ? rightBound - leftBound\r\n    : lowerBound - upperBound;\r\n  var dirX = isHorizontalCut ? 1 : 0;\r\n  var dirY = isHorizontalCut ? 0 : 1;\r\n  await drawWall(\r\n    xStartIdx,\r\n    yStartIdx,\r\n    xPassageIdx,\r\n    yPassageIdx,\r\n    wallDist,\r\n    dirX,\r\n    dirY\r\n  );\r\n\r\n  if (isHorizontalCut) {\r\n    // top section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      rightBound,\r\n      yStartIdx - 1,\r\n      chooseOrientation(leftBound, upperBound, rightBound, yStartIdx - 1)\r\n    );\r\n    // bottom section\r\n    await divide(\r\n      leftBound,\r\n      yStartIdx + 1,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, yStartIdx + 1, rightBound, lowerBound)\r\n    );\r\n  } else {\r\n    // left section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      xStartIdx - 1,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, upperBound, xStartIdx - 1, lowerBound)\r\n    );\r\n\r\n    // right section\r\n    await divide(\r\n      xStartIdx + 1,\r\n      upperBound,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(xStartIdx + 1, upperBound, rightBound, lowerBound)\r\n    );\r\n  }\r\n}\r\n\r\nasync function drawWall(\r\n  xStartIdx,\r\n  yStartIdx,\r\n  xPassageIdx,\r\n  yPassageIdx,\r\n  wallDist,\r\n  dirX,\r\n  dirY\r\n) {\r\n  var xWallIdx = xStartIdx;\r\n  var yWallIdx = yStartIdx;\r\n\r\n  for (let i = 0; i <= wallDist; i++) {\r\n    if (\r\n      xWallIdx === xPassageIdx ||\r\n      yWallIdx === yPassageIdx ||\r\n      cellIsStartOrEnd(xWallIdx, yWallIdx)\r\n    ) {\r\n      xWallIdx += dirX;\r\n      yWallIdx += dirY;\r\n      continue;\r\n    }\r\n    gridCl.grid[yWallIdx][xWallIdx].cellType = CELL_TYPES.OBSTACLE;\r\n    gridCl.grid[yWallIdx][xWallIdx].setCellRerender((rerender) => !rerender);\r\n    xWallIdx += dirX;\r\n    yWallIdx += dirY;\r\n    await timer(1);\r\n  }\r\n}\r\n\r\nfunction choosePassage(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xPassageIdx = 0;\r\n  var yPassageIdx = 0;\r\n\r\n  // must be any odd number between a range because walls are created on even numbers\r\n  if (isHorizontalCut) {\r\n    xPassageIdx = rndOdd(leftBound, rightBound);\r\n    yPassageIdx = upperBound;\r\n  } else {\r\n    xPassageIdx = leftBound;\r\n    yPassageIdx = rndOdd(upperBound, lowerBound);\r\n  }\r\n\r\n  return { xPassageIdx, yPassageIdx };\r\n}\r\n\r\nfunction findStart(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xStartIdx = 0;\r\n  var yStartIdx = 0;\r\n  if (isHorizontalCut) {\r\n    xStartIdx = leftBound;\r\n    /* a horiz wall needs to be on any random EVEN column because the lowerBound - 1 and\r\n    upperBound + 1 are both EVEN inclusive ranges with a grid whose Y-axis length is ODD\r\n    and an outline of 1 is applied */\r\n    yStartIdx = rndEven(upperBound + 1, lowerBound - 1);\r\n  } else {\r\n    /* a vert wall needs to be on any random EVEN row because the rightBound - 1 and\r\n    leftBound + 1 are both EVEN inclusive ranges with a grid whose X-axis length is \r\n    ODD and an outline of 1 is applied */\r\n    xStartIdx = rndEven(leftBound + 1, rightBound - 1);\r\n    yStartIdx = upperBound;\r\n  }\r\n\r\n  return { xStartIdx, yStartIdx };\r\n}\r\n","import React, { useReducer, useState } from \"react\";\r\nimport {\r\n  Alert,\r\n  Button,\r\n  Col,\r\n  Container,\r\n  Form,\r\n  FormControl,\r\n  InputGroup,\r\n  Row,\r\n} from \"react-bootstrap\";\r\nimport AStarSearch from \"../PathFindingAlgos/AStarAlgorithm\";\r\nimport dijkstrasSearch from \"../PathFindingAlgos/DijkstrasAlgorithm\";\r\nimport breadthFirstSearch from \"../PathFindingAlgos/BreadthFirstSearch\";\r\nimport bestFirstSearch from \"../PathFindingAlgos/BestFirstSearch\";\r\nimport startRecursiveDivision from \"../MazeAlgos/RecursiveDivision\";\r\nimport { searchVars, pathFind } from \"../Search\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { mazeVars, createMaze } from \"../Maze\";\r\nimport algoReducer, { initialState } from \"../AlgorithmReducer\";\r\nimport { clamp } from \"../UtilityFuncs\";\r\nimport \"./header.css\";\r\n\r\nfunction Header() {\r\n  const [state, dispatch] = useReducer(algoReducer, initialState);\r\n\r\n  const [canCrossDiagonals, setCanCrossDiagonals] = useState(true);\r\n  const [animationInterval, setAnimationInterval] = useState(15);\r\n  const [missingCell, setMissingCell] = useState(false);\r\n\r\n  const executePathFinding = (algorithm) => {\r\n    if (gridCl.startCell != null && gridCl.endCell != null) {\r\n      pathFind(canCrossDiagonals, dispatch, algorithm);\r\n    } else {\r\n      setMissingCell(true);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Container id=\"header\" className=\"py-3\" fluid>\r\n      <Row className=\"unselectable\">\r\n        <Col>\r\n          <InputGroup className=\"mt-3\">\r\n            <InputGroup.Prepend>\r\n              <InputGroup.Text id=\"prepending-text\">\r\n                Animation Interval (ms)\r\n              </InputGroup.Text>\r\n            </InputGroup.Prepend>\r\n            <FormControl\r\n              id=\"basic-number\"\r\n              aria-describedby=\"prepending-text\"\r\n              value={animationInterval}\r\n              onChange={(evt) => {\r\n                if (evt.target.value !== \"\") {\r\n                  let interval = clamp(\r\n                    parseFloat(evt.target.value),\r\n                    searchVars.minSearchTime,\r\n                    searchVars.maxSearchTime\r\n                  );\r\n                  setAnimationInterval(interval);\r\n                  searchVars.searchAnimationTime = interval;\r\n                }\r\n              }}\r\n              min={searchVars.minSearchTime}\r\n              max={searchVars.maxSearchTime}\r\n              type=\"number\"\r\n            />\r\n          </InputGroup>\r\n        </Col>\r\n        <Col className=\"can-cross-diagonals\">\r\n          <Form>\r\n            <Form.Check\r\n              type=\"switch\"\r\n              id=\"custom-switch\"\r\n              label=\"Can Cross Diagonals\"\r\n              checked={canCrossDiagonals}\r\n              onChange={() =>\r\n                setCanCrossDiagonals((canCrossDiagonals) => !canCrossDiagonals)\r\n              }\r\n            />\r\n          </Form>\r\n        </Col>\r\n        <Col xs={4} className=\"algorithms\">\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => createMaze(startRecursiveDivision, dispatch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Create Maze\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(AStarSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            A*\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(dijkstrasSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Dijkstras\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(breadthFirstSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Breadth First Search\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(bestFirstSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Best First Search\r\n          </Button>\r\n        </Col>\r\n        <Col className=\"clears\">\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (!searchVars.isSearching && !mazeVars.isCreatingMaze) {\r\n                gridCl.clearEntireGrid();\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Clear Entire Grid\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (!mazeVars.isCreatingMaze) {\r\n                gridCl.clearWalls();\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={state.isCreatingMaze ? \"disabled\" : \"\"}\r\n          >\r\n            Clear Walls\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (searchVars.isSearching) {\r\n                searchVars.stopSearch = true;\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={state.isSearching ? \"\" : \"disabled\"}\r\n          >\r\n            Stop Search\r\n          </Button>\r\n        </Col>\r\n        <Col xs={2}>\r\n          <p>\r\n            <b>Ctrl Click:</b> set start cell\r\n          </p>\r\n          <p>\r\n            <b>Alt Click:</b> set end cell\r\n          </p>\r\n        </Col>\r\n      </Row>\r\n      {missingCell ? (\r\n        <Alert\r\n          variant={\"danger\"}\r\n          onClose={() => setMissingCell(false)}\r\n          dismissible\r\n        >\r\n          <Alert.Heading>You are missing a start or end cell</Alert.Heading>\r\n        </Alert>\r\n      ) : (\r\n        <div></div>\r\n      )}\r\n    </Container>\r\n  );\r\n}\r\n\r\nexport default Header;\r\n","import Grid from \"./Grid/Grid\";\nimport Header from \"./Header/Header\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}