{"version":3,"sources":["AlgorithmReducer.js","Maze.js","UtilityFuncs.js","Search.js","Cell/CellActions.js","Cell/Cell.js","Grid/Grid.js","PathFindingAlgos/AStarAlgorithm.js","PathFindingAlgos/DijkstrasAlgorithm.js","DataStructures/Queue.js","PathFindingAlgos/BreadthFirstSearch.js","PathFindingAlgos/BestFirstSearch.js","MazeAlgos/RecursiveDivision.js","Header/Header.js","Footer/Footer.js","Footer/Icons/GitHub-Mark-32px.png","Footer/Icons/Gmail-icon-31px.png","App.js","index.js"],"names":["ALGO_ACTIONS","initialState","isSearching","isCreatingMaze","algoReducer","state","action","type","payload","console","error","mazeVars","mazeAlgo","varDispatch","a","searchVars","gridCl","clearEntireGrid","outlineGrid","then","timer","ms","Promise","resolve","setTimeout","rnd","min","max","Math","floor","random","rndEven","rndOdd","stopSearch","maxSearchTime","minSearchTime","pathAnimationTime","searchAnimationTime","retracePath","start","end","path","currentCell","push","parentCell","reverse","canCrossDiagonals","search","searching","endSearch","drawPath","i","length","cell","isOnPath","setCellRerender","rerender","reject","catch","err","log","CELL_TYPES","cellIsStartOrEnd","posX","posY","grid","startCell","endCell","determineCellType","evt","mouseDown","cellTypeOnMouseDown","cellType","altKey","ctrlKey","x","y","closed","opened","changeCellType","compareFCost","b","comparison","fCost","hCost","compareGCost","gCost","compareHCost","Cell","heapIndex","getCellColor","Error","this","CellSquareState","props","useState","useEffect","rerenderCell","document","onmousedown","onmouseup","CellSquare","cellClass","setCellClass","className","style","backgroundColor","onMouseMove","onMouseDown","onMouseEnter","onMouseLeave","onClick","assignFinishOrStart","maxY","maxX","initGrid","row","getMooreNeighbours","neighbours","cellIsInGrid","getVonNeumannNeighbours","forEach","clearWalls","resetCellsForSearch","cellA","cellB","dstX","abs","dstY","animTime","outLine","Grid","id","map","AStarSearch","resetForSearch","Heap","require","openHeap","closedSet","Set","foundPath","empty","pop","neighbour","has","distCurrentToNeighbour","calculateDistance","newDistStartToNeighbour","updateItem","add","dijkstrasSearch","unvisitedHeap","initHeap","unVisitedNeighbours","filter","tempCurrentCell","distNeighbourToCurrent","Number","MAX_SAFE_INTEGER","heap","Queue","items","head","tail","item","Object","values","indexOf","size","result","key","breadthFirstSearch","unvisitedQueue","initGCosts","enQueue","deQueue","bestFirstSearch","ORIENTATIONS","startRecursiveDivision","divide","chooseOrientation","leftBound","upperBound","rightBound","lowerBound","horizSpace","vertSpace","orientation","findStart","isHorizontalCut","xStartIdx","yStartIdx","choosePassage","xPassageIdx","yPassageIdx","wallDist","dirX","dirY","drawWall","xWallIdx","yWallIdx","Header","useReducer","dispatch","setCanCrossDiagonals","animationInterval","setAnimationInterval","missingCell","setMissingCell","executePathFinding","algorithm","pathFind","Container","fluid","Row","Col","InputGroup","Prepend","Text","FormControl","aria-describedby","value","onChange","target","interval","num","parseFloat","Form","Check","label","checked","xs","Button","variant","createMaze","Alert","onClose","dismissible","Heading","Footer","href","src","alt","title","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.d8b82c37.chunk.js","sourcesContent":["export const ALGO_ACTIONS = {\r\n  IS_SEARCHING: \"IS_SEARCHING\",\r\n  IS_CREATING_MAZE: \"IS_CREATING_MAZE\",\r\n};\r\n// this state represents( but does not manage) the state of the algorithms so the header can change accordingly\r\nexport const initialState = {\r\n  isSearching: false,\r\n  isCreatingMaze: false,\r\n};\r\n\r\nexport default function algoReducer(state, action) {\r\n  switch (action.type) {\r\n    case ALGO_ACTIONS.IS_SEARCHING:\r\n      return {\r\n        ...state,\r\n        isSearching: action.payload,\r\n      };\r\n    case ALGO_ACTIONS.IS_CREATING_MAZE:\r\n      return {\r\n        ...state,\r\n        isCreatingMaze: action.payload,\r\n      };\r\n    default:\r\n      console.error(\"no matching action types\");\r\n  }\r\n}\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { gridCl } from \"./Grid/Grid\";\r\nimport { searchVars } from \"./Search\";\r\n\r\nexport const mazeVars = { isCreatingMaze: false };\r\n\r\n/* Outlines and generates a maze using a given algorithm.\r\n\r\n@param {Function} mazeAlgo - the maze algorithm to run\r\n@param {Function} varDispatch - the dispatch function used to change the state of the Header component\r\n*/\r\nexport async function createMaze(mazeAlgo, varDispatch) {\r\n  if (!mazeVars.isCreatingMaze && !searchVars.isSearching) {\r\n    mazeVars.isCreatingMaze = true;\r\n    varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: true });\r\n\r\n    gridCl.clearEntireGrid();\r\n\r\n    await gridCl.outlineGrid(1).then(() => {\r\n      mazeAlgo().then(() => {\r\n        mazeVars.isCreatingMaze = false;\r\n        varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: false });\r\n      });\r\n    });\r\n  }\r\n}\r\n","export const timer = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nexport const getKeyByValue = (object, value) => {\r\n  return Object.keys(object).find((key) => object[key] === value);\r\n};\r\n\r\nexport const rnd = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nexport const rndEven = (min, max) => {\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2;\r\n  return randomNum;\r\n};\r\n\r\nexport const rndOdd = (min, max) => {\r\n  max = max % 2 === 0 ? max : max - 1;\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2 + 1;\r\n  return randomNum;\r\n};\r\n\r\nexport const clamp = (num, min, max) => Math.min(Math.max(num, min), max);\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { mazeVars } from \"./Maze\";\r\nimport { timer } from \"./UtilityFuncs\";\r\n\r\nexport const searchVars = {\r\n  isSearching: false,\r\n  stopSearch: false,\r\n  maxSearchTime: 3000,\r\n  minSearchTime: 1,\r\n  pathAnimationTime: 10,\r\n  searchAnimationTime: 15,\r\n};\r\n\r\nexport function retracePath(start, end) {\r\n  const path = [];\r\n  var currentCell = end;\r\n\r\n  while (currentCell !== start) {\r\n    path.push(currentCell);\r\n    currentCell = currentCell.parentCell;\r\n  }\r\n  path.reverse();\r\n\r\n  return path;\r\n}\r\n\r\n/*Starts a given pathfinding algorithm and draws the path if found.\r\n\r\n  @param {Function} varDispatch - dispatch function used to change state for the Header component\r\n  @param {Function} searching - the searching algorithm to run\r\n*/\r\nexport async function pathFind(canCrossDiagonals, varDispatch, search) {\r\n  if (searchVars.isSearching || mazeVars.isCreatingMaze) {\r\n    return;\r\n  }\r\n\r\n  searchVars.isSearching = true;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: true });\r\n\r\n  await searching(canCrossDiagonals, search).then(async (path) => {\r\n    if (path == null) {\r\n      endSearch(varDispatch);\r\n      return;\r\n    }\r\n    await drawPath(path);\r\n  });\r\n  endSearch(varDispatch);\r\n}\r\n\r\n/*Ends the searching algorithm and resets state.\r\n\r\n@param {Function} varDispatch - dispatch function used to change state for the Header component\r\n*/\r\nfunction endSearch(varDispatch) {\r\n  searchVars.isSearching = false;\r\n  searchVars.stopSearch = false;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: false });\r\n}\r\n\r\nasync function drawPath(path) {\r\n  for (let i = 0; i < path.length; i++) {\r\n    const cell = path[i];\r\n    cell.isOnPath = true;\r\n    cell.setCellRerender((rerender) => !rerender);\r\n    await timer(searchVars.pathAnimationTime);\r\n  }\r\n}\r\n\r\nfunction searching(canCrossDiagonals, search) {\r\n  return new Promise((resolve, reject) => {\r\n    resolve(\r\n      search(canCrossDiagonals).catch((err) => {\r\n        console.log(err);\r\n        reject(err);\r\n      })\r\n    );\r\n  });\r\n}\r\n","import { gridCl } from \"../Grid/Grid\";\r\nimport { searchVars } from \"../Search\";\r\n\r\nexport const CELL_TYPES = {\r\n  EMPTY: 0,\r\n  START: 1,\r\n  END: 2,\r\n  OBSTACLE: 3,\r\n};\r\n// assigns the start and end cells depending on which cell you click and whether Ctrl or Alt is down.\r\nexport const assignFinishOrStart = (evt, cell) => {\r\n  if (searchVars.isSearching) {\r\n    return;\r\n  }\r\n  if (evt.altKey) {\r\n    if (cell.cellType === CELL_TYPES.END) {\r\n      gridCl.endCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      if (cell.cellType === CELL_TYPES.START) {\r\n        gridCl.startCell = null;\r\n      }\r\n      if (gridCl.endCell != null) {\r\n        changeCellType(gridCl.endCell, CELL_TYPES.EMPTY);\r\n      }\r\n      changeCellType(cell, CELL_TYPES.END);\r\n      gridCl.endCell = cell;\r\n    }\r\n  } else if (evt.ctrlKey) {\r\n    if (cell.cellType === CELL_TYPES.START) {\r\n      gridCl.startCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      if (cell.cellType === CELL_TYPES.END) {\r\n        gridCl.endCell = null;\r\n      }\r\n\r\n      if (gridCl.startCell != null) {\r\n        changeCellType(gridCl.startCell, CELL_TYPES.EMPTY);\r\n      }\r\n      changeCellType(cell, CELL_TYPES.START);\r\n      gridCl.startCell = cell;\r\n    }\r\n  }\r\n};\r\n\r\nexport const cellIsStartOrEnd = (posX, posY) => {\r\n  return (\r\n    gridCl.grid[posY][posX] === gridCl.startCell ||\r\n    gridCl.grid[posY][posX] === gridCl.endCell\r\n  );\r\n};\r\n\r\n// determines the cell type when the mouse is down/hovering over the given cell\r\nexport const determineCellType = (\r\n  evt,\r\n  mouseDown,\r\n  cellTypeOnMouseDown,\r\n  cell\r\n) => {\r\n  if (mouseDown) {\r\n    if (cellTypeOnMouseDown === -1) return;\r\n    const cellType =\r\n      cellTypeOnMouseDown === CELL_TYPES.EMPTY\r\n        ? CELL_TYPES.OBSTACLE\r\n        : CELL_TYPES.EMPTY;\r\n\r\n    if (cell.cellType !== cellType && !evt.altKey && !evt.ctrlKey) {\r\n      if (cellIsStartOrEnd(cell.x, cell.y)) {\r\n        return;\r\n      }\r\n      if ((cell.closed || cell.opened) && searchVars.isSearching) {\r\n        return;\r\n      }\r\n      changeCellType(cell, cellType);\r\n    }\r\n  }\r\n};\r\n\r\nconst changeCellType = (cell, cellType) => {\r\n  cell.cellType = cellType;\r\n  cell.setCellRerender((rerender) => !rerender);\r\n};\r\n\r\n// compare cells by fCost and if needed by hCost\r\nexport function compareFCost(a, b) {\r\n  var comparison = a.fCost() < b.fCost() ? -1 : 1;\r\n\r\n  if (a.fCost() === b.fCost()) {\r\n    comparison = a.hCost < b.hCost ? -1 : 0;\r\n  }\r\n\r\n  return comparison;\r\n}\r\n\r\n// compare cells by gCost\r\nexport function compareGCost(a, b) {\r\n  var comparison = a.gCost < b.gCost ? -1 : 1;\r\n  if (a.gCost === b.gCost) {\r\n    comparison = 0;\r\n  }\r\n  return comparison;\r\n}\r\n\r\n// compare cells by hCost\r\nexport function compareHCost(a, b) {\r\n  var comparison = a.hCost < b.hCost ? -1 : 1;\r\n  if (a.hCost === b.hCost) {\r\n    comparison = 0;\r\n  }\r\n  return comparison;\r\n}\r\n","import React, { useEffect, useState } from \"react\";\r\nimport {\r\n  assignFinishOrStart,\r\n  determineCellType,\r\n  CELL_TYPES,\r\n} from \"./CellActions\";\r\nimport \"./cell.css\";\r\n\r\nexport default class Cell {\r\n  setCellRerender = null;\r\n  isOnPath = false;\r\n  opened = false;\r\n  closed = false;\r\n  cellType = CELL_TYPES.EMPTY;\r\n\r\n  // the cost from this cell to the start cell\r\n  gCost = 0;\r\n\r\n  // the cost from this cell to the end cell\r\n  hCost = 0;\r\n\r\n  // the total cost\r\n  fCost = () => this.hCost + this.gCost;\r\n\r\n  heapIndex = -1;\r\n\r\n  parentCell = null;\r\n\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  getCellColor = () => {\r\n    if (\r\n      (!this.opened && !this.isOnPath && !this.closed) ||\r\n      this.cellType !== 0\r\n    ) {\r\n      switch (this.cellType) {\r\n        case CELL_TYPES.EMPTY:\r\n          return \"rgba(221, 221, 221, 0.603)\";\r\n        case CELL_TYPES.START:\r\n          return \"green\";\r\n        case CELL_TYPES.END:\r\n          return \"red\";\r\n        case CELL_TYPES.OBSTACLE:\r\n          return \"black\";\r\n        default:\r\n          throw new Error(\"Out of range exception\");\r\n      }\r\n    } else if (this.isOnPath) {\r\n      return \"lightskyblue\";\r\n    } else if (this.closed) {\r\n      return \"lightgray\";\r\n    } else if (this.opened) {\r\n      return \"lightgreen\";\r\n    }\r\n  };\r\n}\r\n\r\nvar mouseDown = false;\r\nvar cellTypeOnMouseDown = -1;\r\n\r\nexport function CellSquareState(props) {\r\n  const { cell } = props;\r\n  const [, setCellRerender] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (cell.rerenderCell == null) {\r\n      cell.setCellRerender = setCellRerender;\r\n    }\r\n  }, [cell]);\r\n\r\n  document.onmousedown = () => (mouseDown = true);\r\n\r\n  document.onmouseup = () => {\r\n    mouseDown = false;\r\n    cellTypeOnMouseDown = -1;\r\n  };\r\n\r\n  return <CellSquare state={{ cell }} />;\r\n}\r\n\r\nfunction CellSquare({ state }) {\r\n  const { cell } = state;\r\n  const [cellClass, setCellClass] = useState(\"load-cell\");\r\n  return (\r\n    <div\r\n      className={cellClass}\r\n      style={{ backgroundColor: cell.getCellColor() }}\r\n      onMouseMove={(evt) =>\r\n        determineCellType(evt, mouseDown, cellTypeOnMouseDown, cell)\r\n      }\r\n      onMouseDown={(evt) => {\r\n        cellTypeOnMouseDown = cell.cellType;\r\n        determineCellType(evt, true, cellTypeOnMouseDown, cell);\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (cellClass !== \"cell-hovered\") {\r\n          setCellClass(\"cell-hovered\");\r\n        }\r\n      }}\r\n      onMouseLeave={() => {\r\n        if (cellClass !== \"cell-unhovered\") {\r\n          setCellClass(\"cell-unhovered\");\r\n        }\r\n      }}\r\n      onClick={(evt) => assignFinishOrStart(evt, cell)}\r\n    ></div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport Cell, { CellSquareState } from \"../Cell/Cell\";\r\nimport { CELL_TYPES, cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport \"./grid.css\";\r\n/*The Grid\r\nThe GridCl class contains all the cells that will be used to path find as well as the start and end cell.\r\nThe dimensions should be odd to work with recursive division.\r\n\r\nIt contains functions that manage the state of the grid.\r\n */\r\n\r\nclass GridCl {\r\n  grid = [];\r\n  startCell = null;\r\n  endCell = null;\r\n\r\n  maxY = 27;\r\n  maxX = 61;\r\n\r\n  constructor() {\r\n    this.initGrid();\r\n  }\r\n  initGrid = () => {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      var row = [];\r\n      for (let x = 0; x < this.maxX; x++) {\r\n        row.push(new Cell(x, y));\r\n      }\r\n      this.grid.push(row);\r\n    }\r\n\r\n    // place the start node a quarter away from the left bound\r\n    let startCell = this.grid[Math.floor(this.maxY / 2)][\r\n      Math.floor(this.maxX / 4)\r\n    ];\r\n\r\n    // place the end node a quarter away from the right bound\r\n    let endCell = this.grid[Math.floor(this.maxY / 2)][\r\n      Math.floor(this.maxX - this.maxX / 4)\r\n    ];\r\n\r\n    startCell.cellType = CELL_TYPES.START;\r\n    endCell.cellType = CELL_TYPES.END;\r\n\r\n    this.startCell = startCell;\r\n    this.endCell = endCell;\r\n  };\r\n\r\n  /* get the 8 or less surrounding neighbours of a cell at indices posX and posY\r\n\r\n    does not retrieve the neighbour if it is not in the grid\r\n\r\n    @param {number} posX - the x-index of a given cell whose neighbours we are checking\r\n    @param {number} posY - the y-index of a given cell whose neighbours we are checking\r\n\r\n    @return {Array} neighbours - contains up to 8 surrounding neighbours\r\n   */\r\n  getMooreNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n    for (var y = -1; y <= 1; y++) {\r\n      for (var x = -1; x <= 1; x++) {\r\n        if (x === 0 && y === 0) {\r\n          continue;\r\n        }\r\n        if (!this.cellIsInGrid(posX + x, posY + y)) {\r\n          continue;\r\n        }\r\n\r\n        neighbours.push(this.grid[posY + y][posX + x]);\r\n      }\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  /* get top, left, right, and down neighbours of a cell at indices posX and posY\r\n\r\n    Does not retrieve the neighbour if it is not in the grid\r\n\r\n    @param {number} posX - the x-index of a given cell whose neighbours we are checking\r\n    @param {number} posY - the y-index of a given cell whose neighbours we are checking\r\n\r\n    @return {Array} neighbours - contains up to 4 surrounding neighbours\r\n   */\r\n  getVonNeumannNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n\r\n    if (this.cellIsInGrid(posX - 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX - 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX + 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX + 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY - 1)) {\r\n      neighbours.push(this.grid[posY - 1][posX]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY + 1)) {\r\n      neighbours.push(this.grid[posY + 1][posX]);\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  /* Checks if a cell is in the grid\r\n\r\n  @param {number} x - the x-index of a cell\r\n  @param {number} y - the y-index of a cell\r\n\r\n  @returns {boolean} if given cell index at x and y is contained within the 2d array */\r\n  cellIsInGrid = (x, y) => {\r\n    if (x < 0 || y < 0 || x >= this.maxX || y >= this.maxY) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  // revert every single cell back to empty other then the start and end cells\r\n  clearEntireGrid = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (\r\n          cell.cellType !== CELL_TYPES.EMPTY &&\r\n          cell.cellType !== CELL_TYPES.START &&\r\n          cell.cellType !== CELL_TYPES.END\r\n        ) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  resetForSearch() {\r\n    return new Promise((resolve, reject) => {\r\n      resolve(\r\n        this.resetCellsForSearch().catch((err) => {\r\n          console.log(err);\r\n          reject(err);\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  // reset any opened, closed, or onPath cells\r\n  async resetCellsForSearch() {\r\n    gridCl.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  clearWalls = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        if (cell.cellType === CELL_TYPES.OBSTACLE) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  /* Calculates the distance between to cells\r\n\r\n  distance for diagonal algorithms is calculated using octile distance.\r\n  distance for non-diagonal algorithms is calculated using manhattan distance.\r\n\r\n  @param {Object} cellA - the first cell\r\n  @param {Object} cellB - the second cell\r\n  @param {boolean} canCrossDiagonals - whether the cellA can cross diagonals to get to cellB vice-versa\r\n\r\n  @return {float} the distance between cellA and cellB\r\n  */\r\n  calculateDistance(cellA, cellB, canCrossDiagonals) {\r\n    if (canCrossDiagonals) {\r\n      var dstX = Math.abs(cellA.x - cellB.x);\r\n      var dstY = Math.abs(cellA.y - cellB.y);\r\n\r\n      if (dstX > dstY) {\r\n        return 14 * dstY + 10 * (dstX - dstY);\r\n      }\r\n\r\n      return 14 * dstX + 10 * (dstY - dstX);\r\n    } else {\r\n      return Math.abs(cellA.x - cellB.x) + Math.abs(cellA.y - cellB.y);\r\n    }\r\n  }\r\n\r\n  outlineGrid(animTime) {\r\n    return new Promise((resolve, reject) =>\r\n      resolve(\r\n        this.outLine(animTime).catch((err) => {\r\n          console.log(err);\r\n          reject(err);\r\n        })\r\n      )\r\n    );\r\n  }\r\n\r\n  /*Outlines the grid with a cell of type Obstacle\r\n\r\n  @param {float} animTime - the animation time to wait before drawing the next cell\r\n  */\r\n  async outLine(animTime) {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      if (!cellIsStartOrEnd(0, y)) {\r\n        // outlines left wall\r\n        this.grid[y][0].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][0].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(this.maxX - 1, y)) {\r\n        // outlines right wall\r\n        this.grid[y][this.maxX - 1].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][this.maxX - 1].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n    for (let x = 0; x < this.maxX; x++) {\r\n      if (!cellIsStartOrEnd(x, 0)) {\r\n        // outlines top wall\r\n        this.grid[0][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[0][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(x, this.maxY - 1)) {\r\n        // outlines bottom wall\r\n        this.grid[this.maxY - 1][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[this.maxY - 1][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n  }\r\n}\r\n\r\nexport const gridCl = new GridCl();\r\n\r\nfunction Grid() {\r\n  return (\r\n    <section id=\"grid\">\r\n      {gridCl.grid.map((row) =>\r\n        row.map((cell) => {\r\n          return <CellSquareState cell={cell} key={cell.x + \" \" + cell.y} />;\r\n        })\r\n      )}\r\n    </section>\r\n  );\r\n}\r\n\r\nexport default Grid;\r\n","import { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareFCost } from \"../Cell/CellActions\";\r\nimport { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\n\r\n/*A* Search Algorithm\r\n\r\nUses a min heap to compare fCosts/hCosts to find the next cell\r\nto check.\r\n\r\nAlways finds a shortest path.\r\n\r\n@param {boolean} canCrossDiagonals - whether the path should be able to cross diagonals\r\n@returns {Array} path - The path or null if no path is found\r\n\r\n*/\r\nexport default async function AStarSearch(canCrossDiagonals) {\r\n  await gridCl.resetForSearch();\r\n  var Heap = require(\"heap\");\r\n  const openHeap = new Heap(compareFCost);\r\n\r\n  const closedSet = new Set();\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n  openHeap.push(startCell);\r\n\r\n  var foundPath = false;\r\n\r\n  while (!openHeap.empty()) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    const currentCell = openHeap.pop();\r\n\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    var neighbours = [];\r\n\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const neighbour = neighbours[i];\r\n      if (\r\n        neighbour.cellType === CELL_TYPES.OBSTACLE ||\r\n        closedSet.has(neighbour)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      const distCurrentToNeighbour = gridCl.calculateDistance(\r\n        currentCell,\r\n        neighbour,\r\n        canCrossDiagonals\r\n      );\r\n\r\n      // calculate the distance from the start to the neighbour through the current cell\r\n      const newDistStartToNeighbour =\r\n        currentCell.gCost + distCurrentToNeighbour;\r\n\r\n      if (newDistStartToNeighbour < neighbour.gCost || !neighbour.opened) {\r\n        neighbour.gCost = newDistStartToNeighbour;\r\n        neighbour.hCost = gridCl.calculateDistance(\r\n          neighbour,\r\n          endCell,\r\n          canCrossDiagonals\r\n        );\r\n        neighbour.parentCell = currentCell;\r\n\r\n        if (!neighbour.opened) {\r\n          openHeap.push(neighbour);\r\n          neighbour.opened = true;\r\n\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        } else {\r\n          openHeap.updateItem(neighbour);\r\n        }\r\n      }\r\n    }\r\n\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    closedSet.add(currentCell);\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareGCost } from \"../Cell/CellActions\";\r\n\r\n/* Dijkstras Search Algorithm\r\n\r\nUses a min heap that compares gCosts to find the next cell to \r\ncheck too.\r\n\r\nAlways finds a shortest path.\r\n\r\n@param {boolean} canCrossDiagonals - whether the path should be able to cross diagonals\r\n@returns {Array} path - The path or null if no path is found\r\n\r\n*/\r\nexport default async function dijkstrasSearch(canCrossDiagonals) {\r\n  await gridCl.resetForSearch();\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  var Heap = require(\"heap\");\r\n\r\n  const unvisitedHeap = new Heap(compareGCost);\r\n  await initHeap(unvisitedHeap);\r\n\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n\r\n  startCell.gCost = 0;\r\n  unvisitedHeap.updateItem(startCell);\r\n\r\n  var currentCell = unvisitedHeap.pop();\r\n  var neighbours = [];\r\n  var foundPath = false;\r\n\r\n  while (!unvisitedHeap.empty()) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      const distNeighbourToCurrent = gridCl.calculateDistance(\r\n        tempCurrentCell,\r\n        neighbour,\r\n        canCrossDiagonals\r\n      );\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        const newDistStartToNeighbour =\r\n          tempCurrentCell.gCost + distNeighbourToCurrent;\r\n\r\n        if (newDistStartToNeighbour < neighbour.gCost) {\r\n          neighbour.gCost = newDistStartToNeighbour;\r\n\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n          unvisitedHeap.updateItem(neighbour);\r\n        }\r\n      }\r\n    });\r\n\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n\r\n    currentCell = unvisitedHeap.pop();\r\n\r\n    if (currentCell.gCost === Number.MAX_SAFE_INTEGER) {\r\n      break;\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  }\r\n  console.log(\"no path found\");\r\n}\r\n\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n          heap.push(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","/*Queue\r\nData structure that follows FIFO\r\n */\r\n\r\nexport default class Queue {\r\n  items = {};\r\n  head = 0;\r\n  tail = 0;\r\n\r\n  /*enqueues a given item with O(1) time complexity\r\n\r\n  @param {any} item - an item to add to the queue\r\n  */\r\n  enQueue(item) {\r\n    this.items[this.tail] = item;\r\n    this.tail++;\r\n  }\r\n  contains(item) {\r\n    return Object.values(this.items).indexOf(item) > -1 ? true : false;\r\n  }\r\n\r\n  // dequeues with O(1) time complexity\r\n  deQueue() {\r\n    if (this.size() <= 0) return undefined;\r\n\r\n    // get the item at the start of the queue\r\n    var item = this.items[this.head];\r\n\r\n    delete this.items[this.head];\r\n\r\n    // now there are no items at the head key so we must increment it to point to the next head\r\n    this.head++;\r\n\r\n    if (this.head === this.tail) {\r\n      this.head = 0;\r\n      this.tail = 0;\r\n    }\r\n\r\n    return item;\r\n  }\r\n\r\n  size() {\r\n    return this.tail - this.head;\r\n  }\r\n\r\n  peek() {\r\n    return this.items[this.head];\r\n  }\r\n\r\n  print() {\r\n    var result = [];\r\n    for (let key in this.items) {\r\n      result.push(this.items[key]);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\nimport Queue from \"../DataStructures/Queue\";\r\n\r\n/* Breadth First Search Algorithm\r\n\r\nUses a Queue to choose the next cell to check.\r\nUses the boolean var opened instead of an openedSet.\r\n\r\nAlways finds a shortest path.\r\n\r\n@param {boolean} canCrossDiagonals - whether the path should be able to cross diagonals\r\n@returns {Array} path - The path or null if no path is found\r\n\r\n*/\r\n\r\nexport default async function breadthFirstSearch(canCrossDiagonals) {\r\n  await gridCl.resetForSearch();\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  const unvisitedQueue = new Queue();\r\n  await initGCosts();\r\n\r\n  startCell.parentCell = startCell;\r\n\r\n  var currentCell = null;\r\n\r\n  var neighbours = [];\r\n\r\n  startCell.opened = true;\r\n  startCell.gCost = 0;\r\n\r\n  unvisitedQueue.enQueue(startCell);\r\n  var foundPath = false;\r\n\r\n  while (unvisitedQueue.size() > 0) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    currentCell = unvisitedQueue.deQueue();\r\n\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    for (let i = 0; i < unVisitedNeighbours.length; i++) {\r\n      var neighbour = unVisitedNeighbours[i];\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        if (!neighbour.closed && !neighbour.opened) {\r\n          unvisitedQueue.enQueue(neighbour);\r\n        }\r\n        const distCurrentToNeighbour = gridCl.calculateDistance(\r\n          tempCurrentCell,\r\n          neighbour,\r\n          canCrossDiagonals\r\n        );\r\n\r\n        // calculate the new distance from start to neighbour through the current cell\r\n        const newDistStartToNeighbour =\r\n          tempCurrentCell.gCost + distCurrentToNeighbour;\r\n\r\n        if (newDistStartToNeighbour < neighbour.gCost) {\r\n          neighbour.gCost = newDistStartToNeighbour;\r\n\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        }\r\n      }\r\n    }\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n  }\r\n}\r\n\r\nfunction initGCosts() {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          // initialize all the gCosts to be as large as possible as none have been visited yet\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareHCost } from \"../Cell/CellActions\";\r\n\r\n/* Best First Search Algorithm\r\n\r\nUses a min heap that compares hCosts to find the next cell to \r\ncheck too.\r\n\r\nDoes not always find the shortest path.\r\n\r\n@param {boolean} canCrossDiagonals - whether the path should be able to cross diagonals\r\n@returns {Array} path - The path or null if no path is found\r\n\r\n*/\r\n\r\nexport default async function bestFirstSearch(canCrossDiagonals) {\r\n  await gridCl.resetForSearch();\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  var Heap = require(\"heap\");\r\n  const unvisitedHeap = new Heap(compareHCost);\r\n\r\n  await initHeap(unvisitedHeap);\r\n\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n\r\n  startCell.gCost = 0;\r\n  startCell.hCost = gridCl.calculateDistance(\r\n    startCell,\r\n    endCell,\r\n    canCrossDiagonals\r\n  );\r\n  unvisitedHeap.updateItem(startCell);\r\n\r\n  var neighbours = [];\r\n  var foundPath = false;\r\n  while (!unvisitedHeap.empty()) {\r\n    var currentCell = unvisitedHeap.pop();\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    if (currentCell.hCost === Number.MAX_SAFE_INTEGER) {\r\n      break;\r\n    }\r\n\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    const unVisitedNeighbours = neighbours.filter(\r\n      (x) => !x.closed && !x.opened\r\n    );\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        neighbour.hCost = gridCl.calculateDistance(\r\n          neighbour,\r\n          endCell,\r\n          canCrossDiagonals\r\n        );\r\n\r\n        neighbour.parentCell = tempCurrentCell;\r\n\r\n        neighbour.opened = true;\r\n        neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n        unvisitedHeap.updateItem(neighbour);\r\n      }\r\n    });\r\n\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n  }\r\n}\r\n\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.hCost = Number.MAX_SAFE_INTEGER;\r\n          heap.push(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { rndEven, rndOdd, timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\n\r\n/*Recursive Division\r\n\r\nMaze creation algorithm that recursively seperates the grid into sections.\r\nEach section is seperated by a wall with a single passage.\r\n\r\nThe maze chooses whether to place vertical or horizontal walls in accordance \r\nto each sections dimensions.\r\n*/\r\n\r\nconst ORIENTATIONS = {\r\n  HORIZONTAL: \"HORIZONTAL\",\r\n  VERTICAL: \"VERTICAL\",\r\n};\r\n\r\nexport default function startRecursiveDivision() {\r\n  return new Promise((resolve, reject) => {\r\n    resolve(\r\n      divide(\r\n        1,\r\n        1,\r\n        gridCl.maxX - 2,\r\n        gridCl.maxY - 2,\r\n        chooseOrientation(1, 1, gridCl.maxX - 2, gridCl.maxY - 2)\r\n      ).catch((err) => {\r\n        console.log(err);\r\n        reject(err);\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/* Determines whether to do a horizontal or vertical wall\r\n\r\nhorizontal space is greater than the vertical cut vertically vice-versa\r\n\r\n@param {number} leftBound - the left most bound of the current section\r\n@param {number} upperBound - the upper most bound of the current section\r\n@param {number} rightBound - the right most bound of the current section\r\n@param {number} lowerBound - the lower most bound of the current section\r\n\r\n@return {string} orientation - the orientation of the wall to place\r\n*/\r\nfunction chooseOrientation(leftBound, upperBound, rightBound, lowerBound) {\r\n  const horizSpace = rightBound - leftBound;\r\n  const vertSpace = lowerBound - upperBound;\r\n\r\n  if (horizSpace > vertSpace) {\r\n    return ORIENTATIONS.VERTICAL;\r\n  } else if (vertSpace > horizSpace) {\r\n    return ORIENTATIONS.HORIZONTAL;\r\n  } else {\r\n    return Math.random() > 0.5\r\n      ? ORIENTATIONS.HORIZONTAL\r\n      : ORIENTATIONS.VERTICAL;\r\n  }\r\n}\r\n\r\nconst passageSize = 1;\r\n\r\n/*Recursively divides the grid into sections\r\n\r\nEach section is seperated by a wall with a passage.\r\n\r\n@param {number} leftBound - the left most bound of the current section\r\n@param {number} upperBound - the upper most bound of the current section\r\n@param {number} rightBound - the right most bound of the current section\r\n@param {number} lowerBound - the lower most bound of the current section\r\n\r\n@param {string} orientation - the orientation of the wall to place\r\n*/\r\nasync function divide(\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound,\r\n  orientation\r\n) {\r\n  if (\r\n    rightBound - leftBound <= passageSize ||\r\n    lowerBound - upperBound <= passageSize\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  var isHorizontalCut = orientation === ORIENTATIONS.HORIZONTAL;\r\n\r\n  const { xStartIdx, yStartIdx } = findStart(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n\r\n  const { xPassageIdx, yPassageIdx } = choosePassage(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n\r\n  var wallDist = isHorizontalCut\r\n    ? rightBound - leftBound\r\n    : lowerBound - upperBound;\r\n\r\n  var dirX = isHorizontalCut ? 1 : 0;\r\n  var dirY = isHorizontalCut ? 0 : 1;\r\n\r\n  await drawWall(\r\n    xStartIdx,\r\n    yStartIdx,\r\n    xPassageIdx,\r\n    yPassageIdx,\r\n    wallDist,\r\n    dirX,\r\n    dirY\r\n  );\r\n\r\n  if (isHorizontalCut) {\r\n    // top section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      rightBound,\r\n      yStartIdx - 1,\r\n      chooseOrientation(leftBound, upperBound, rightBound, yStartIdx - 1)\r\n    );\r\n    // bottom section\r\n    await divide(\r\n      leftBound,\r\n      yStartIdx + 1,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, yStartIdx + 1, rightBound, lowerBound)\r\n    );\r\n  } else {\r\n    // left section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      xStartIdx - 1,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, upperBound, xStartIdx - 1, lowerBound)\r\n    );\r\n\r\n    // right section\r\n    await divide(\r\n      xStartIdx + 1,\r\n      upperBound,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(xStartIdx + 1, upperBound, rightBound, lowerBound)\r\n    );\r\n  }\r\n}\r\n\r\n/* Draws the wall at a given start point and avoids placing a wall at a given passage point \r\n\r\nThe wall also avoids placing walls where there is a start or end cell\r\n\r\n@param {number} xStartIdx - the x-index in the grid to start drawing the wall\r\n@param {number} yStartIdx - the y-index in the grid to start drawing the wall\r\n@param {number} xPassageIdx - the x-index in the grid to avoid placing a wall\r\n@param {number} yPassageIdx - the y-index in the grid to avoid placing a wall\r\n@param {number} wallDist - the number of cells to draw on\r\n@param {number} dirX - the direction to draw cells on the x-axis\r\n@param {number} dirY - the direction to draw cells on the y-axis\r\n*/\r\nasync function drawWall(\r\n  xStartIdx,\r\n  yStartIdx,\r\n  xPassageIdx,\r\n  yPassageIdx,\r\n  wallDist,\r\n  dirX,\r\n  dirY\r\n) {\r\n  var xWallIdx = xStartIdx;\r\n  var yWallIdx = yStartIdx;\r\n\r\n  for (let i = 0; i <= wallDist; i++) {\r\n    if (\r\n      xWallIdx === xPassageIdx ||\r\n      yWallIdx === yPassageIdx ||\r\n      cellIsStartOrEnd(xWallIdx, yWallIdx)\r\n    ) {\r\n      xWallIdx += dirX;\r\n      yWallIdx += dirY;\r\n      continue;\r\n    }\r\n    gridCl.grid[yWallIdx][xWallIdx].cellType = CELL_TYPES.OBSTACLE;\r\n    gridCl.grid[yWallIdx][xWallIdx].setCellRerender((rerender) => !rerender);\r\n\r\n    xWallIdx += dirX;\r\n    yWallIdx += dirY;\r\n\r\n    await timer(1);\r\n  }\r\n}\r\n\r\n/*Chooses the point to place a passage\r\n\r\nOnly place passages on odd indices so they do not intersect with walls.\r\n\r\n@param {boolean} isHorizontalCut - whether the wall that is being placed is horizontal or not\r\n@param {number} leftBound - the left most bound of the current section\r\n@param {number} upperBound - the upper most bound of the current section\r\n@param {number} rightBound - the right most bound of the current section\r\n@param {number} lowerBound - the lower most bound of the current section\r\n\r\n@return {Object} object containing the x and y indices of the passage\r\n*/\r\nfunction choosePassage(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xPassageIdx = 0;\r\n  var yPassageIdx = 0;\r\n\r\n  if (isHorizontalCut) {\r\n    xPassageIdx = rndOdd(leftBound, rightBound);\r\n    yPassageIdx = upperBound;\r\n  } else {\r\n    xPassageIdx = leftBound;\r\n    yPassageIdx = rndOdd(upperBound, lowerBound);\r\n  }\r\n\r\n  return { xPassageIdx, yPassageIdx };\r\n}\r\n\r\n/*Finds the starting point to place the wall\r\n\r\nYou want walls to be on even indices so they cannot be created right beside\r\nthe grid outline as it would leave no room for a path.\r\n\r\n@param {boolean} isHorizontalCut - whether the wall that is being placed is horizontal or not\r\n@param {number} leftBound - the left most bound of the current section\r\n@param {number} upperBound - the upper most bound of the current section\r\n@param {number} rightBound - the right most bound of the current section\r\n@param {number} lowerBound - the lower most bound of the current section\r\n\r\n@return {Object} object containing the x and y indices of the wall start\r\n*/\r\nfunction findStart(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xStartIdx = 0;\r\n  var yStartIdx = 0;\r\n  if (isHorizontalCut) {\r\n    xStartIdx = leftBound;\r\n    yStartIdx = rndEven(upperBound + 1, lowerBound - 1);\r\n  } else {\r\n    xStartIdx = rndEven(leftBound + 1, rightBound - 1);\r\n    yStartIdx = upperBound;\r\n  }\r\n\r\n  return { xStartIdx, yStartIdx };\r\n}\r\n","import React, { useReducer, useState } from \"react\";\r\nimport {\r\n  Alert,\r\n  Button,\r\n  Col,\r\n  Container,\r\n  Form,\r\n  FormControl,\r\n  InputGroup,\r\n  Row,\r\n} from \"react-bootstrap\";\r\nimport AStarSearch from \"../PathFindingAlgos/AStarAlgorithm\";\r\nimport dijkstrasSearch from \"../PathFindingAlgos/DijkstrasAlgorithm\";\r\nimport breadthFirstSearch from \"../PathFindingAlgos/BreadthFirstSearch\";\r\nimport bestFirstSearch from \"../PathFindingAlgos/BestFirstSearch\";\r\nimport startRecursiveDivision from \"../MazeAlgos/RecursiveDivision\";\r\nimport { searchVars, pathFind } from \"../Search\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { mazeVars, createMaze } from \"../Maze\";\r\nimport algoReducer, { initialState } from \"../AlgorithmReducer\";\r\nimport { clamp } from \"../UtilityFuncs\";\r\nimport \"./header.css\";\r\n\r\nfunction Header() {\r\n  const [state, dispatch] = useReducer(algoReducer, initialState);\r\n\r\n  const [canCrossDiagonals, setCanCrossDiagonals] = useState(true);\r\n  const [animationInterval, setAnimationInterval] = useState(15);\r\n  const [missingCell, setMissingCell] = useState(false);\r\n\r\n  const executePathFinding = (algorithm) => {\r\n    if (gridCl.startCell != null && gridCl.endCell != null) {\r\n      pathFind(canCrossDiagonals, dispatch, algorithm);\r\n    } else {\r\n      setMissingCell(true);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Container id=\"header\" className=\"py-3\" fluid>\r\n      <Row className=\"unselectable\">\r\n        <Col>\r\n          <InputGroup className=\"mt-3\">\r\n            <InputGroup.Prepend>\r\n              <InputGroup.Text id=\"prepending-text\">\r\n                Animation Interval (ms)\r\n              </InputGroup.Text>\r\n            </InputGroup.Prepend>\r\n            <FormControl\r\n              id=\"basic-number\"\r\n              aria-describedby=\"prepending-text\"\r\n              value={animationInterval}\r\n              onChange={(evt) => {\r\n                if (evt.target.value !== \"\") {\r\n                  let interval = clamp(\r\n                    parseFloat(evt.target.value),\r\n                    searchVars.minSearchTime,\r\n                    searchVars.maxSearchTime\r\n                  );\r\n                  setAnimationInterval(interval);\r\n                  searchVars.searchAnimationTime = interval;\r\n                }\r\n              }}\r\n              min={searchVars.minSearchTime}\r\n              max={searchVars.maxSearchTime}\r\n              type=\"number\"\r\n            />\r\n          </InputGroup>\r\n        </Col>\r\n        <Col className=\"can-cross-diagonals\">\r\n          <Form>\r\n            <Form.Check\r\n              type=\"switch\"\r\n              id=\"custom-switch\"\r\n              label=\"Can Cross Diagonals\"\r\n              checked={canCrossDiagonals}\r\n              onChange={() =>\r\n                setCanCrossDiagonals((canCrossDiagonals) => !canCrossDiagonals)\r\n              }\r\n            />\r\n          </Form>\r\n        </Col>\r\n        <Col xs={4} className=\"algorithms\">\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => createMaze(startRecursiveDivision, dispatch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Create Maze\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(AStarSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            A*\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(dijkstrasSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Dijkstras\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(breadthFirstSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Breadth First Search\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-dark\"\r\n            onClick={() => executePathFinding(bestFirstSearch)}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Best First Search\r\n          </Button>\r\n        </Col>\r\n        <Col className=\"clears\">\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (!searchVars.isSearching && !mazeVars.isCreatingMaze) {\r\n                gridCl.clearEntireGrid();\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Clear Entire Grid\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (!mazeVars.isCreatingMaze && !searchVars.isSearching) {\r\n                gridCl.clearWalls();\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={\r\n              state.isCreatingMaze || searchVars.isSearching ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Clear Walls\r\n          </Button>\r\n          <Button\r\n            variant=\"outline-danger\"\r\n            onClick={() => {\r\n              if (searchVars.isSearching) {\r\n                searchVars.stopSearch = true;\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={state.isSearching ? \"\" : \"disabled\"}\r\n          >\r\n            Stop Search\r\n          </Button>\r\n        </Col>\r\n        <Col xs={2}>\r\n          <p>\r\n            <b>Ctrl Click:</b> set start cell\r\n          </p>\r\n          <p>\r\n            <b>Alt Click:</b> set end cell\r\n          </p>\r\n        </Col>\r\n      </Row>\r\n      {missingCell ? (\r\n        <Alert\r\n          variant={\"danger\"}\r\n          onClose={() => setMissingCell(false)}\r\n          dismissible\r\n        >\r\n          <Alert.Heading>You are missing a start or end cell</Alert.Heading>\r\n        </Alert>\r\n      ) : (\r\n        <div></div>\r\n      )}\r\n    </Container>\r\n  );\r\n}\r\n\r\nexport default Header;\r\n","import React from \"react\";\r\nimport { Col, Container, Row } from \"react-bootstrap\";\r\nimport \"./footer.css\";\r\nimport GitHubLogo from \"./Icons/GitHub-Mark-32px.png\";\r\nimport GmailLogo from \"./Icons/Gmail-icon-31px.png\";\r\n\r\nexport default function Footer() {\r\n  return (\r\n    <Container id=\"footer\" className=\"py-3\" fluid>\r\n      <Row>\r\n        <Col>\r\n          <a href=\"https://github.com/TheRaizer/PathFinding-Algorithms\">\r\n            <img\r\n              src={GitHubLogo}\r\n              alt=\"unavailable\"\r\n              className=\"logo\"\r\n              title=\"github repository\"\r\n            />\r\n          </a>\r\n        </Col>\r\n        <Col>\r\n          <a href=\"mailto:aidan.fu000@gmail.com\">\r\n            <img\r\n              src={GmailLogo}\r\n              alt=\"unavailable\"\r\n              className=\"logo\"\r\n              title=\"send email\"\r\n            />\r\n          </a>\r\n        </Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n}\r\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNTE3OEEyQTk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNTE3OEEyQjk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTI4OTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTI5OTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+m4QGuQAAAyRJREFUeNrEl21ojWEYx895TDPbMNlBK46IUiNmPvHBSUjaqc0H8pF5+aDUKPEBqU2NhRQpX5Rv5jWlDIWlMCv7MMSWsWwmb3tpXub4XXWdPHvc9/Gc41nu+nedc7/8r/99PffLdYdDPsvkwsgkTBwsA/PADJCnzX2gHTwBt8Hl7p537/3whn04XoDZDcpBlk+9P8AFcAghzRkJwPF4zGGw0Y9QS0mAM2AnQj77FqCzrtcwB1Hk81SYojHK4DyGuQ6mhIIrBWB9Xm7ug/6B/nZrBHBegrkFxoVGpnwBMSLR9EcEcC4qb8pP14BWcBcUgewMnF3T34VqhWMFkThLJAalwnENOAKiHpJq1FZgI2AT6HZtuxZwR9GidSHtI30jOrbawxlVX78/AbNfhHlomEUJJI89O2MqeE79T8/nk8nMBm/dK576hZgmA3cp/R4l9/UeSxiHLVIlNm4nFfT0bxyuIj7LHRTKai+zdJobwMKzcZSJb0ePV5PKN+BqAAKE47UlMnERELMM3EdYP/yrd+XYb2mOiYBiQ8OQnoRBlXrl9JZix7D1pHTazu4MoyBcnYamqAjIMTR8G4FT8LuhLsexXYYjICBiqhQBvYb6fLZIJCjPypVvaOoVAW2WcasCnL2Nq82xHJNSqlCeFcDshaPK0twkAhosjZL31QYw+1rlMpWGMArl23SBsZZO58F2tlJXmjOXS+s4WGvpMiBJT/I2PInZ6lIs9/hBsNS1hS6BG0DSqmYEDRlCXQrmy50P1oDRKTSegmNbUsA0zDMwRhPJXeCE3vWLPQMvan6X8AgIa1vcR4AkGZkDR4ejJ1UHpsaVI0g2LInpOsNFUud1rhxSV+fzC9Woz2EZkWQuja7/B+jUrgtIMpy9YCW4n4K41YfzRneW5E1KJTe4B2Zq1Q5EHEtj4U3AfEzR5SVY4l7QYQPJdN2as7RKBF0BPZqqH4VgMAMBL8Byxr7y8zCZiDlnOcEKIPmUpgB5Z2ww5RdOiiRiNajUmWda5IG6WbhsyY2fx6m8gLcoJDJFkH219M3We1+cnda93pfycZpIJEL/s/wSYADmOAwAQgdpBAAAAABJRU5ErkJggg==\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAAfCAYAAAB6Q+RGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAVyGAAFchgG6kO1AAAAAB3RJTUUH5QIVDy4iQmHbqQAABApJREFUWMPtl11sk1UYx3/nvG+6sY260bHgwBQXcHUNjouVaEiM2kS50QtgapZIvFAMF0ZjQDAbaIyJ8WvRRKNCVBLQTJ0fyUCZ6AUxS5YMZcKFCeLi4kTbBd3Gxtq1fR8vela6UWjfdqgX/m/eN+c8zzm/8zznU/U1+AGagd3AncAi4EfgZaALmFk/NMzVUuJrG8AD3A9sB24EpoGvgGeBk6qvwb8W2Ae0zPOfAN4EXgLOASwkrIED8AE7gG2Ad57ZceAhbSLYkqMdr3E+UFnhaX5yaJhoOLQggNFwCDucJPGztxnhgOnHm8O0Bdij+hr845cxyKiudvFPNddUdDiOfAok674ZKAkQsGVGbyxfN/pcxYZfV6PkSi4Tdj5AAK3VahHZB9wEdEbDoT8B3MBmZWEJ8ISy5VGJay9IPlevdhEEL7AL2A8E53VcKGDQ+O8qJDiZILmABLCAu4FuYCNg5wOdTa+x7zb+lptObVEa7aQQpdz4BYB3gNeAV6Ph0BjMTX8WfDXwOPCY+S9YCiGFRh9Zt53xqmVoSbkMKtVAB/Cugc6AZQEGTH2HW0ALIeJU8PpUEMtq635mZOkaaieGqZ48Cyo9hmxVVZZR5rFztaVJb763AyPAmR0Ny4WL0+Jt4FZyTStRWHXTeAJjc7pTgEb4IeHjham1HI2vQCtx+GVZCx/e8QoDgXtJaQ9KHLdRnV0QO4EV5rvflBcsjZBA81lsJe3nQ5xI+NAINoCWFOOV13L4lnb+8AW47cRbeC9EcJSr+V0DPA1sAa4nfdS5Sm/UKee9C430xP3ExMIy21Mmh0ocklYZ/U1tRKpXcddAJ9dFB0G52gA8QKPbNGiEk8klvDHVxPeJ2kzZxfo5EpQIQ/U30xXu5LsbNpHSNkrybrhFSQFJND1xP+0TIY4nlqKYvyKyIjlnZJJirGo5Pet3E/E1yn2/fZBaLNP2pe6lAY6JJ/nRVND6PO5X02Jn0ntppC/XiDgkrHL6gluc3sYH91qS6l/IKFo4/e/X1u/tijc4MbHmpLdgyPRoBYWoQyvbjtVMn20FDgIzJfLNAAdrJpKtHzdVH1NC3mOkoFWhJaXawt+OkL7ztQOjRQKOGv9t9zziH7FECpo/BS/dyKJ6gEmgE3gAGHQJOGj8OoHJ3712wY6u9hdzNjtAL9BK+nmRyOOWMHatxs9xex91ewvKvkScAbYCezDPixw6Z+q3GntXd9BZFR7zHKDRcOg88CJwCngeWJNldgp4CviymOiVFMkcsA5wGNgMfALEzHezKS8JsGTILFCA08DDwCbzPT2vvmgVle4rgP4FfLEQbWar5Ej+E/ofciEhY/82RB7FNOlT4L+sXpv0e0QBG3B55b/KmgGOADv/BgSHTWWkYBDkAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTAyLTIxVDE1OjQ2OjM0LTA1OjAws/Rk6gAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wMi0yMVQxNTo0NjozNC0wNTowMMKp3FYAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC\"","import Grid from \"./Grid/Grid\";\nimport Header from \"./Header/Header\";\nimport Footer from \"./Footer/Footer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Grid />\n      <Footer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}